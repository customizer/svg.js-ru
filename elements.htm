<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>svg.js Справочное руководство</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>

<body>
<h3>Элементы</h3>
<tt>SVG.Element</tt> - это базовый прототип SVG.js, охватывающий все элементы (или узлы, коли на то пошло). С помощью <tt>SVG.Shape</tt> добавляется дополнительный уровень обработки.
Каждый элемент может принимать атрибут <tt>fill</tt> и/или <tt>stroke</tt>. Предпочтительней расширять элементы собственными методами на <tt>SVG.Shape</tt>, а не на <tt>SVG.Element</tt>.<br><br>

<h4 id="1">SVG.Rect</h4>
<div class=blockindent><br>
<pre id="1rect"><span class="lnk" onmouseover="show('rect - сокращ. англ. слова rectangle, rectangular - прямоугольник')" onmouseout="hide()">rect()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Rect</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
У прямоугольников два аргумента, это его ширина (<tt>width</tt>) и высота (<tt>height</tt>):
<pre>// javascript
var rect = draw.rect(100, 100)</pre><br>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("rect1","rect2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("rect2","rect1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="http://jsfiddle.net/wout/wmtt8rkz/7/?utm_source=website&utm_medium=embed&utm_campaign=wmtt8rkz" target="_blank">Редактировать в JSFiddle</a></span>
<div id="rect1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/rect.png"></div>
<div id="rect2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(300, 130)<br>
var rect = draw.rect(100, 100).fill('#f06').move(20, 20)</pre></div></div><br>

<pre id="1rect.radius"><span class="lnk" onmouseover="show('rectangular radius - радиус прямоугольника, т.е.<br>радиус закругления углов прямоугольника')" onmouseout="hide()"><span class="shadow">rect.</span>radius()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Также у прямоугольников могут быть закругленные углы:
<pre>// javascript
rect.radius(10)</pre>
Этот код устанавливает атрибуты <tt>rx</tt> и <tt>ry</tt> равные <tt>10</tt>. Код ниже для раздельной установки <tt>rx</tt> и <tt>ry</tt>
<pre>// javascript
rect.radius(10, 20)</pre></div><br><br>


<h4 id="2">SVG.Circle</h4>
<div class=blockindent><br>
<pre id="2circle"><span class="lnk" onmouseover="show('circle - круг, окружность')" onmouseout="hide()">circle()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Circle</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
Для круга необходим только один аргумент - диаметр:
<pre>// javascript
var circle = draw.circle(100)</pre><br>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("circle1","circle2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("circle2","circle1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="http://jsfiddle.net/wout/79gmh7jf/?utm_source=website&utm_medium=embed&utm_campaign=79gmh7jf" target="_blank">Редактировать в JSFiddle</a></span>
<div id="circle1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/circle.png"></div>
<div id="circle2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(300, 130)<br>
var rect = draw.circle(100).fill('#f06').move(20, 20)</pre></div></div><br>

<pre id="2circle.radius"><span class="lnk" onmouseover="show('circle radius - радиус круга')" onmouseout="hide()"><span class="shadow">circle.</span>radius()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
<pre>// javascript
circle.radius(75)</pre></div><br><br>


<h4 id="3">SVG.Ellipse</h4>
<div class=blockindent><br>
<pre id="2ellipse"><span class="lnk" onmouseover="show('ellipse - эллипс')" onmouseout="hide()">circle()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Circle</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
У эллипсов два аргумента, это его ширина (<tt>width</tt>) и высота (<tt>height</tt>):
<pre>// javascript
var ellipse = draw.ellipse(200, 100)</pre><br>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("ellipse1","ellipse2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("ellipse2","ellipse1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="https://jsfiddle.net/wout/mr7kjab1/1/?utm_source=website&utm_medium=embed&utm_campaign=mr7kjab1" target="_blank">Редактировать в JSFiddle</a></span>
<div id="ellipse1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/ellipse.png"></div>
<div id="ellipse2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(300, 130)<br>
var ellipse = draw.ellipse(150, 100).fill('#f06').move(20, 20)</pre></div></div><br>

<pre id="3ellipse.radius"><span class="lnk" onmouseover="show('ellipse radius - радиус эллипса')" onmouseout="hide()"><span class="shadow">ellipse.</span>radius()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Эллипсы также могут переопределяться по своим радиусам:
<pre>// javascript
ellipse.radius(75, 50)</pre></div><br><br>


<h4 id="4">SVG.Line</h4>
<div class=blockindent><br>
<pre id="4line"><span class="lnk" onmouseover="show('line - линия')" onmouseout="hide()">line()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Line</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
Создает линию от точки <tt>A</tt> до точки <tt>B</tt>:
<pre>// javascript
var line = draw.line(0, 0, 100, 150).stroke({ width: 1 })</pre>
Создание элемента &#171;линия&#187; (<tt>line</tt>) может быть выполнено четырьмя способами. Посмотрите на метод <tt>plot()</tt>, чтобы увидеть все его возможности.
Creating a line element can be done in four ways. Look at the `plot()` method to see all the possibilities.<br><br>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("line1","line2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("line2","line1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="https://jsfiddle.net/wout/1z9LmLha/3/?utm_source=website&utm_medium=embed&utm_campaign=1z9LmLha" target="_blank">Редактировать в JSFiddle</a></span>
<div id="line1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/line.png"></div>
<div id="line2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(300, 130)<br>
var line = draw.line(0, 100, 100, 0).move(20, 20)
line.stroke({ color: '#f06', width: 10, linecap: 'round' })</pre></div></div><br>

<pre id="4line.array"><span class="lnk" onmouseover="show('line array - массив линий')" onmouseout="hide()"><span class="shadow">line.</span>array()</span></pre>
<div class=list>возвращает - <tt>SVG.PointArray</tt></div>

References the `SVG.PointArray` instance. Этот метод предназначен скорее для внутреннего использования:
<pre>// javascript
polyline.array()</pre>

Больше сведений смотрите в: <a href="classes.htm#2" onmouseover="show('SVG.PointArray')" onmouseout="hide()">SVG.PointArray</a>.<br><br>

<pre id="4line.plot"><span class="lnk" onmouseover="show('line plot - план (прокладка) линии')" onmouseout="hide()"><span class="shadow">line.</span>plot()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
С помощью метода <tt>plot()</tt> выполняется обновление линии:
<pre>// javascript
line.plot(50, 30, 100, 150)</pre>
Кроме того, метод принимает последовательность точек:
<pre>// javascript
line.plot('0,0 100,150')</pre>
или массив точек:
<pre>// javascript
line.plot([[0, 0], [100, 150]])</pre>
или экземпляр <tt><a href="classes.htm#2" onmouseover="show('SVG.PointArray')" onmouseout="hide()">SVG.PointArray</a></tt>:
<pre>// javascript
var array = new SVG.PointArray([[0, 0], [100, 150]])
line.plot(array)</pre>
Метод <tt>plot()</tt> также можно анимировать:
<pre>// javascript
line.animate(3000).plot([[200, 200], [100, 150]])</pre></div><br><br>


<h4 id="5">SVG.Polyline</h4>
<div class=blockindent><br>
<pre id="5polyline"><span class="lnk" onmouseover="show('polyline - ломаная линия')" onmouseout="hide()">polyline()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Polyine</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
Элемент &#171;ломаная линия&#187; (<tt>polyline</tt>) определяет набор, связанных между собой, отрезков прямой линии. Обычно ломаные линии представляют собой незамкнутые фигуры:
The polyline element defines a set of connected straight line segments. Typically, polyline elements define open shapes:
<pre>// javascript
var polyline = draw.polyline('0,0 100,50 50,100').fill('none').stroke({ width: 1 })</pre>
Строки кода ломаной линии состоят из списка точек, разделенных между собой запятыми или пробелами. Так что, вполне будут работать как <tt>x,y x,y x,y</tt>, так и <tt>x y x y x y</tt> или даже <tt>x,y,x,y,x,y</tt>.<br>
Как альтернатива, будет работать и массив точек:
<pre>// javascript
var polyline = draw.polyline([[0,0], [100,50], [50,100]])</pre>
Или, что предпочтительнее, даже плоский массив точек:
<pre>// javascript
var polyline = draw.polyline([0,0, 100,50, 50,100])</pre><br>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("polyline1","polyline2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("polyline2","polyline1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="https://jsfiddle.net/wout/6wt24q7p/2/?utm_source=website&utm_medium=embed&utm_campaign=6wt24q7p" target="_blank">Редактировать в JSFiddle</a></span>
<div id="polyline1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/polyline.png"></div>
<div id="polyline2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(300, 130)<br>
var polyline = draw.polyline('50,0 60,40 100,50 60,60 50,100 40,60 0,50 40,40')
polyline.fill('none').move(20, 20)
polyline.stroke({ color: '#f06', width: 4, linecap: 'round', linejoin: 'round' })</pre></div></div><br>

<pre id="5polyline.array"><span class="lnk" onmouseover="show('polyline array - массив ломаных линий')" onmouseout="hide()"><span class="shadow">polyline.</span>array()</span></pre>
<div class=list>возвращает - <tt>SVG.PointArray</tt>.</div>
References the `SVG.PointArray` instance. Этот метод предназначен скорее для внутреннего использования:
<pre>// javascript
polyline.array()</pre>
Больше сведений смотрите в: <a href="classes.htm#2" onmouseover="show('SVG.PointArray')" onmouseout="hide()">SVG.PointArray</a>.<br><br>

<pre id="5polyline.clear"><span class="lnk" onmouseover="show('polyline clear - очистка ломаных линий')" onmouseout="hide()"><span class="shadow">polyline.</span>clear()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
При анализе данных задаваемой точки, результат <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88" target="_blank" onmouseover="show(cache)" onmouseout="hide()">кэшируется</a>. Данный метод очищает кэш.
<pre>// javascript
polyline.clear()</pre><br>

<pre id="5polyline.plot"><span class="lnk" onmouseover="show('polyline plot - план (прокладка) ломаных линий')" onmouseout="hide()"><span class="shadow">polyline.</span>plot()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
С помощью метода <tt>plot()</tt> можно обновлять ломаные линии:
<pre>// javascript
polyline.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])</pre>
Метод <tt>plot()</tt> также можно анимировать:
<pre>// javascript
polyline.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])</pre></div><br><br>


<h4 id="6">SVG.Polygon</h4>
<div class=blockindent><br>
<pre id="6polygon"><span class="lnk" onmouseover="show('polygon - многоугольник, полигон')" onmouseout="hide()">polygon()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Polygon</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
Элемент &#171;многоугольник&#187; (<tt>polygon</tt>), в отличие от элемента &#171;ломаная линия&#187; (<tt>polyline</tt>), представляется в виде замкнутой формы, состоящей из набора отрезков прямых линий, соединенных между собой:
<pre>// javascript
var polygon = draw.polygon('0,0 100,50 50,100').fill('none').stroke({ width: 1 })</pre>
Строки или массивы многоугольника в точности те же самые, что и строки ломаной линии. При этом не нужно замыкать форму отрезком линии между первой и последней точками, это будет сделано автоматически.<br><br>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("polygon1","polygon2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("polygon2","polygon1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="http://jsfiddle.net/wout/4aqnwLy0/?utm_source=website&utm_medium=embed&utm_campaign=4aqnwLy0" target="_blank">Редактировать в JSFiddle</a></span>
<div id="polygon1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/polygon.png"></div>
<div id="polygon2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(300, 130)<br>
var polygon = draw.polygon('50,0 60,40 100,50 60,60 50,100 40,60 0,50 40,40')
polygon.fill('#f06').move(20, 20)</pre></div></div><br>

<pre id="6polygon.array"><span class="lnk" onmouseover="show('polygon array - массив многоугольника')" onmouseout="hide()"><span class="shadow">polygon.</span>array()</span></pre>
<div class=list>возвращает - <tt>SVG.PointArray</tt>.</div>
Ссылается на экземпляр <a href="classes.htm#2" onmouseover="show('SVG.PointArray')" onmouseout="hide()">SVG.PointArray</a>. Этот метод предназначен скорее для внутреннего использования:
<pre>// javascript
polygon.array()</pre>
Больше сведений смотрите в: <a href="classes.htm#2" onmouseover="show('SVG.PointArray')" onmouseout="hide()">SVG.PointArray</a>.<br><br>

<pre id="6polygon.clear"><span class="lnk" onmouseover="show('polygon clear - очистка многоугольника')" onmouseout="hide()"><span class="shadow">polygon.</span>clear()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
При анализе данных задаваемой точки, результат <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88" target="_blank" onmouseover="show(cache)" onmouseout="hide()">кэшируется</a>. Данный метод очищает кэш.
<pre>// javascript
polygon.clear()</pre><br>

<pre id="6polygon.plot"><span class="lnk" onmouseover="show('polygon plot - план (прокладка) многоугольника')" onmouseout="hide()"><span class="shadow">polygon.</span>plot()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Подобно ломаным линиям, многоугольники могут быть обновлены с помощью метода <tt>plot()</tt>:
<pre>// javascript
polygon.plot([[0,0], [100,50], [50,100], [150,50], [200,50]])</pre>
Метод <tt>plot()</tt> также можно анимировать:
<pre>// javascript
polygon.animate(3000).plot([[0,0], [100,50], [50,100], [150,50], [200,50], [250,100], [300,50], [350,50]])</pre></div><br><br>


<h4 id="7">SVG.Path</h4>
<div class=note_trans><b>Примечание переводчика:</b> В переводе на русский язык слово "path" означает путь, контур, траекторию, дорожку и т.д. Здесь оно будет называться "путь" и обозначать контур фигуры, замкнутый и разомкнутый, из прямых и кривых линий.</div>
<div class=blockindent><br>
<pre id="7path"><span class="lnk" onmouseover="show('path - путь, контур')" onmouseout="hide()">path()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Path</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
Строка данных, определяющая путь, похожа на строку данных многоугольника, но намного сложнее из-за поддержки кривых линий.
<pre>// javascript
draw.path('M0 0 H50 A20 20 0 1 0 100 50 v25 C50 125 0 85 0 85 z')</pre><br>

<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("path1","path2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("path2","path1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="http://jsfiddle.net/wout/oxaxp55z/2/?utm_source=website&utm_medium=embed&utm_campaign=oxaxp55z" target="_blank">Редактировать в JSFiddle</a></span>
<div id="path1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/path.png"></div>
<div id="path2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(300, 130)<br>
var path = draw.path('M0 0 H50 A20 20 0 1 0 100 50 v25 C50 125 0 85 0 85 z')
path.fill('none').move(20, 20)
path.stroke({ color: '#f06', width: 4, linecap: 'round', linejoin: 'round' })</pre></div></div><br>
Для более подробных сведений о строках данных пути посмотрите <a href="http://www.w3.org/TR/SVG/paths.html#PathData" target="_blank">SVG документацию по данным пути</a>.<br><br>

<pre id="7path.array"><span class="lnk" onmouseover="show('path array - массив пути')" onmouseout="hide()"><span class="shadow">path.</span>array()</span></pre>
<div class=list>возвращает - <tt>SVG.PathArray</tt></div>
Ссылается на экземпляр <tt>SVG.PathArray</tt>. Этот метод предназначен скорее для внутреннего использования:
<pre>// javascript
path.array()</pre>
Для большей информации смотрите <a href="classes.htm#3" onmouseover="show('SVG.PathArray')" onmouseout="hide()">SVG.PathArray</a>.<br><br>

<pre id="7path.clear"><span class="lnk" onmouseover="show('path clear - очистка пути')" onmouseout="hide()"><span class="shadow">path.</span>clear()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
При анализе данных пути, результат <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88" target="_blank" onmouseover="show(cache)" onmouseout="hide()">кэшируется</a>. Данный метод очищает кэш.
<pre>// javascript
path.clear()</pre><br>

<pre id="7path.length"><span class="lnk" onmouseover="show('path length - длина пути')" onmouseout="hide()"><span class="shadow">path.</span>length()</span></pre>
<div class=list>возвращает - число (<tt>number</tt>)</div>
Метод получает полную длину элемента <tt>path</tt>:
<pre>// javascript
var length = path.length()</pre><br>

<pre id="7path.pointAt"><span class="lnk" onmouseover="show('path point at - точка пути на (расстоянии)')" onmouseout="hide()"><span class="shadow">path.</span>pointAt()</span></pre>
<div class=list>возвращает - <tt>SVGPoint</tt></div>
Метод получает точку на пути по заданной длине:
<pre>// javascript
var point = path.pointAt(105)</pre>
<div class=note><b>Примечание:</b> метод <tt>pointAt()</tt> возвращает локальный <tt>SVGPoint</tt>, а не <tt>SVG.Point</tt>.</div><br>

<pre id="7path.plot"><span class="lnk" onmouseover="show('path plot - построить путь')" onmouseout="hide()"><span class="shadow">path.</span>plot()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
С помощью метода <tt>plot()</tt> можно обновлять пути:
<pre>// javascript
path.plot('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80')</pre>
Также метод <tt>plot()</tt> может быть анимирован:
<pre>// javascript
path.animate(2000).plot('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80').loop(true, true)</pre>
Существует только базовая поддержка анимации путей, прописанных в SVG.js, то есть, анимация возможна только для путей с теми же командами (<tt>M</tt>, <tt>C</tt>, <tt>S</tt> и т.д.).<br>
Если нужна анимация путей, которые не разделяют вышеупомянутые команды надлежащим образом, можно использовать плагин
<a href="https://github.com/Fuzzyma/svg.pathmorphing.js" target="_blank" onmouseover="show('плагин для библиотеки SVG.js для включения морфинга/анимации пути')" onmouseout="hide()">svg.pathmorphing.js</a>.</div><br><br>


<h4 id="8">SVG.Text</h4>
Более подробно о тексте посмотреть в "<a href="https://css-live.ru/articles/glava-5-element-text.html" target="_blank">Карманном руководстве по написанию SVG</a>".
<div class=blockindent><br>
<pre id="8text"><span class="lnk" onmouseover="show('text - текст')" onmouseout="hide()">text()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Text</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
В отличие от html, текст в svg намного сложнее приручить. Способа создания поступающего текста не существует, так что символы новой строки (<tt>\n</tt>) должны вводиться вручную.
В SVG.js есть два способа создания текстовых элементов.<br>
Первый и самый простой способ - предоставить строку текста, разделенную символами новой строки:
<pre>// javascript
var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")</pre>
Этот код автоматически создаст блок текста и вставит символы новой строки, где они необходимы.<br>
Второй способ даст вам гораздо больше контроля, но и потребует чуть больше кода:
<pre>// javascript
var text = draw.text(function(add) {
  add.tspan('Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur').fill('#f06')
  add.tspan('.')
  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)
  add.tspan('Nunc ultrices lectus at erat').newLine()
  add.tspan('dictum pharetra elementum ante').newLine()
})</pre>
Можно сделать и по-другому, вообще без применения блоков текста (<tt>tspan</tt>), когда нужно просто добавить одну строку текста воспользуйтесь методом <tt>plain()</tt>:
<pre>// javascript
var text = draw.plain('Lorem ipsum dolor sit amet consectetur.')</pre>

This is a shortcut to the `plain` method on the `SVG.Text` instance which doesn't render newlines at all.<br><br>

<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("text1","text2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("text2","text1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="http://jsfiddle.net/wout/7pdww24q/5/?utm_source=website&utm_medium=embed&utm_campaign=7pdww24q" target="_blank">Редактировать в JSFiddle</a></span>
<div id="text1" style="height:100px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<div style="background-color:#fff; display:block; margin:20px; padding:20px; font-family:Segoe UI; color:#f06;">I know that eggs do well to stay out of frying pans.</div></div>
<div id="text2" style="height:100px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(500, 50)<br>
var text = draw.text('I know that eggs do well to stay out of frying pans.')
text.move(20,20).font({ fill: '#f06', family: 'Inconsolata' })</pre></div></div><br>

<pre id="8text.build"><span class="lnk" onmouseover="show('text build - собрать текст')" onmouseout="hide()"><span class="shadow">text.</span>build()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Метод <tt>build()</tt> можно использовать для включения/отключения режима сборки текста. В режиме отключенного создания перед добавлением нового контента, методы <tt>plain()</tt> и <tt>tspan()</tt> сначала будут вызывать метод <tt>clear()</tt>.
Когда же режим сборки включен, методы <tt>plain()</tt> и <tt>tspan()</tt> будут присоединять новый контент к уже существующему. При передаче блока текста методу <tt>text()</tt> режим сборки автоматически переключается до и после вызова блока.
Но в некоторых случаях может понадобится возможность переключать его вручную:
<pre>// javascript
var text = draw.text('This is just the start, ')<br>
text.build(true)  // enables build mode (включаем режим сборки)<br>
var tspan = text.tspan('something pink in the middle ').fill('#00ff97')
text.plain('and again boring at the end.')<br>
text.build(false) // disables build mode (отключаем режим сборки)<br>
tspan.animate('2s').fill('#f06')</pre><br>

<pre id="8text.clear"><span class="lnk" onmouseover="show('text clear - очистка текста')" onmouseout="hide()"><span class="shadow">text.</span>clear()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Очистка всего содержимого вызываемого текстового элемента:
<pre>// javascript
text.clear()</pre><br>

<pre id="8text.length"><span class="lnk" onmouseover="show('text length - длина текста')" onmouseout="hide()"><span class="shadow">text.</span>length()</span></pre>
<div class=list>возвращает - число (<tt>number</tt>)</div>
Получает общую вычисленную длину текста всех текстовых блоков (<tt>tspan</tt>) вместе:
<pre>// javascript
text.length()</pre><br>

<pre id="8text.font_set"><span class="lnk" onmouseover="show('text font - шрифт текста')" onmouseout="hide()"><span class="shadow">text.</span>font()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
Удобный метод для добавления свойств шрифта:
<pre>// javascript
text.font({
  family:   'Helvetica'
, size:     144
, anchor:   'middle'
, leading:  '1.5em'
})</pre>
Мало чем отличаясь от метода <tt>attr()</tt>, метод <tt>font()</tt> также принимает пару ключ/значение:
<pre>// javascript
text.font('family', 'Menlo')</pre>
Доступные свойства:<br>
&nbsp; &#9679; &nbsp; <tt>leading</tt> (делает то же самое, что и вызов метода <tt>leading()</tt> как установщика)<br>
&nbsp; &#9679; &nbsp; <tt>anchor</tt> (устанавливает атрибут <tt>text-anchor</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>family</tt> (устанавливает атрибут <tt>font-family</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>size</tt> (устанавливает атрибут <tt>font-size</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>stretch</tt> (устанавливает атрибут <tt>font-stretch</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>style</tt> (устанавливает атрибут <tt>font-style</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>variant</tt> (устанавливает атрибут <tt>font-variant</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>weight</tt> (устанавливает атрибут <tt>font-weight</tt>)<br>
Любое другое свойство будет применяться как задано. Так например, свойство <tt>letter-spacing</tt> будет применяться так, как было задано методом <tt>attr()</tt>.
Подробнее о свойствах шрифта <a href="https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG" target="_blank">здесь</a>.<br><br>

<pre id="8text.font_get"><span class="lnk" onmouseover="show('text font - шрифт текста')" onmouseout="hide()"><span class="shadow">text.</span>font()</span>          <i class=low>как получатель (геттер)</i></pre>
Как и следовало ожидать, метод <tt>font()</tt> также действует как получатель (геттер):
<pre>// javascript
var leading = text.font('leading')</pre><br>

<pre id="8text.leading_set"><span class="lnk" onmouseover="show('text leading - текстовая направляющая')" onmouseout="hide()"><span class="shadow">text.</span>leading()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
В отличие от <tt>html</tt>, где направляющая текста определяется параметром <tt>line-height</tt>, в svg нет естественного эквивалента направляющей. В svg строки не определяются обычным способом.
Они устанавливаются в узлах <tt>&#60;tspan&#62;</tt> атрибутами <tt>dy</tt> определяющего высоту строки, и <tt>x</tt>, который переустанавливает строку в позицию по оси координат <tt>x</tt> родительского элемента текста.
При этом, также можно в одной строке иметь множество узлов с разными значениями <tt>y</tt>, <tt>dy</tt>, <tt>x</tt> или даже <tt>dx</tt>. Это дает большую свободу, а также и большую ответственность.
Следует решить, как будет определена новая строка, где она начинается, каково ее смещение и высота.
Метод <tt>leading()</tt> в SVG.js пытается облегчить страдания, задавая поведение, наиболее приближенное к <tt>html</tt>. В сочетании с текстом, разделяемым символом новой строки, он работает почти так же, как <tt>html</tt>:
<pre>// javascript
var text = draw.text("Lorem ipsum dolor sit amet consectetur.\nCras sodales imperdiet auctor.")
text.leading(1.3)</pre>

This will render a text element with a tspan element for each line, with a `dy` value of `130%` of the font size.<br>

Note that the `leading()` method assumes that every first level tspan in a text node represents a new line. Using `leading()` on text elements containing multiple tspans in one line (e.g. without a wrapping tspan defining a new line) will render scrambled. So it is advisable to use this method with care, preferably only when throwing newline separated text at the text element or calling the `newLine()` method on every first level tspan added in the block passed as an argument to the text element.<br><br>

<pre id="8text.leading_get"><span class="lnk" onmouseover="show('text leading - текстовая направляющая')" onmouseout="hide()"><span class="shadow">text.</span>leading()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает - значение (value)</div>

Get the current leading value:
<pre>// javascript
var leading = text.leading()</pre><br>

<pre id="8text.lines"><span class="lnk" onmouseover="show('text lines - линии текста')" onmouseout="hide()"><span class="shadow">text.</span>lines()</span></pre>
<div class=list>возвращает - <tt>SVG.Set</tt></div>

All first level tspans can be referenced with the `lines()` method:
<pre>// javascript
text.lines()</pre>

This will return an instance of `SVG.Set` including all `tspan` elements.<br><br>

<pre id="8text.plain"><span class="lnk" onmouseover="show('text plain - простой (обычный) текст')" onmouseout="hide()"><span class="shadow">text.</span>plain()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

If the content of the element doesn't need any styling or multiple lines, it might be sufficient to just add some plain text:
<pre>// javascript
text.plain('I do not have any expectations.')</pre><br>

<pre id="8text.rebuild"><span class="lnk" onmouseover="show('text rebuild - перестроить текст')" onmouseout="hide()"><span class="shadow">text.</span>rebuild()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Это внутренняя функция обратного вызова, которую, возможно, никогда не понадобиться вызывать вручную.
В основном он перестраивает текстовый элемент при изменении атрибутов <tt>font-size</tt> и <tt>x</tt> или <tt>leading()</tt> текстового элемента.
Этот метод действует также как установщик для включения или отключения перестройки текста:
<pre>// javascript
text.rebuild(false) // -> disables rebuilding (отключает перестройку)
text.rebuild(true)  // -> enables rebuilding and instantaneously rebuilds the text element
                    // -> включает перестройку и мгновенно перестраивает текстовый элемент</pre><br>

<pre id="8text.text_set"><span class="lnk" onmouseover="show('text text - текст элемента text')" onmouseout="hide()"><span class="shadow">text.</span>text()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>

Changing text afterwards is also possible with the `text()` method:
<pre>// javascript
text.text('Brilliant!')</pre><br>

<pre id="8text.text_get"><span class="lnk" onmouseover="show('text text - текст элемента text')" onmouseout="hide()"><span class="shadow">text.</span>text()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает - строку (<tt>string</tt>)</div>
Метод для получения необработанного текстового содержимого:
<pre>// javascript
text.text()</pre><br>

<pre id="8text.tspan"><span class="lnk" onmouseover="show('text t(ext) span - текст текстового блока')" onmouseout="hide()"><span class="shadow">text.</span>tspan()</span></pre>
<div class=list>возвращает - <tt>SVG.Tspan</tt></div>

Just adding one tspan is also possible:
<pre>// javascript
text.tspan(' on a train...').fill('#f06')</pre></div><br><br>


<h4 id="9">SVG.TextPath</h4>
<div class=blockindent><br>
<pre id="9path"><span class="lnk" onmouseover="show('path - путь')" onmouseout="hide()">path()</span>  <i class=low>конструктор для textPath</i></pre>
<div class=list>конструктор на <tt>SVG.Text</tt></div>
<div class=list>возвращает - <tt>SVG.TextPath</tt>, который наследует от <tt>SVG.Text</tt>.</div>

A nice feature in svg is the ability to run text along a path:
<pre>// javascript
var text = draw.text(function(add) {
  add.tspan('We go ')
  add.tspan('up').fill('#f09').dy(-40)
  add.tspan(', then we go down, then up again').dy(40)
})<br>
var path = 'M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100'<br>
text.path(path).font({ size: 42.5, family: 'Verdana' })</pre>

When calling the `path()` method on a text element, the text element is mutated into an intermediate between a text and a path element. From that point on the text element will also feature a `plot()` method to update the path:

<pre>// javascript
text.plot('M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100')</pre>

Attributes specific to the `&#60;textPath&#62;` element can be applied to the textPath instance itself:

<pre>// javascript
text.textPath().attr('startOffset', '50%')</pre>
И конечно же, они могут быть анимированы:
<pre>// javascript
text.textPath().animate(3000).attr('startOffset', '80%')</pre>

<div class=note><b>Примечание:</b> If a `startOffset` other than a percentage is given, then the value represents a distance along the path measured in the current user coordinate system.</div><br>

<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("dragon1","dragon2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("dragon2","dragon1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="https://jsfiddle.net/wout/7wL1uv8n/?utm_source=website&utm_medium=embed&utm_campaign=7wL1uv8n" target="_blank">Редактировать в JSFiddle</a></span>
<div id="dragon1" style="height:350px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<div style="font-size:110%; border:1px solid #808080; margin:0px; padding:4px;"><tt>Dragon----- - - - -></tt></div>
<img src="img/dragon.gif"></div>
<div id="dragon2" style="height:350px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var input = document.querySelector('input[type=text]')
var draw = SVG('drawing').viewbox(0, 0, 300, 140)
var text = draw.text(function(add) {
	add.tspan( input.value )
})<br>
text
	.path('M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80')
	.animate(1000, '&#60;&#62;')
	.plot('M10 80 C 40 150, 65 150, 95 80 S 150 10, 180 80')
	.loop(true, true)<br>
input.addEventListener('keyup', updateText(text))<br>
function updateText(textPath) {
	return function() {
		textPath.tspan(this.value)
	}
}</pre></div></div><br>

<pre id="9textPath.array"><span class="lnk" onmouseover="show('text path array - массив пути текста')" onmouseout="hide()"><span class="shadow">textPath.</span>array()</span></pre>
<div class=list>возвращает - <tt>SVG.PathArray</tt></div>

Get the path array of the underlying path:
<pre>// javascript
var array = text.textPath().array()</pre><br>

<pre id="9textPath.plot"><span class="lnk" onmouseover="show('text path plot - построить путь текста')" onmouseout="hide()"><span class="shadow">textPath.</span>plot()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод изменяет путь в элементе <tt>textPath</tt>:
<pre>// javascript
text.textPath().plot('M 300 500 C 200 100 300 0 400 100 C 500 200 600 300 700 200')</pre><br>

<pre id="9textPath.textPath"><span class="lnk" onmouseover="show('text path text path - текстовый путь текстового пути')" onmouseout="hide()"><span class="shadow">textPath.</span>textPath()</span></pre>
<div class=list>возвращает - <tt>SVG.TextPath</tt></div>
Прямая ссылка на узел (node) <tt>textPath</tt>:
<pre>// javascript
var textPath = text.textPath()</pre><br>

<pre id="9textPath.track"><span class="lnk" onmouseover="show('text path track - трек текстового пути')" onmouseout="hide()"><span class="shadow">textPath.</span>track()</span></pre>
<div class=list>возвращает - <tt>SVG.Path</tt></div>
Прямая ссылка на связанный элемент пути:
<pre>// javascript
var path = text.track()</pre>
<div class=note><b>Примечание:</b> <tt>SVG.TextPath</tt> наследует от <tt>SVG.Text</tt>, так что все эти методы также наследуются.</div><br>

<h5>События для <tt>SVG.Text</tt></h5>
Текстовый элемент имеет одно событие. Оно наступает всякий раз при вызове метода <tt>rebuild()</tt>.
<pre>// javascript
text.on('rebuild', function() {
  // whatever you need to do after rebuilding (все, что нужно сделать после перестройки)
})</pre></div><br><br>


<h4 id="10">SVG.Tspan</h4>
<div class=blockindent><br>
<pre id="10tspan"><span class="lnk" onmouseover="show('tspan - text span - блок текста')" onmouseout="hide()">image()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Text</tt></div>
<div class=list>возвращает - <tt>SVG.Tspan</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
Элементы <tt>tspan</tt> возможны только внутри текстовых элементов или внутри других элементов <tt>tspan</tt>.
<pre>// javascript
text.tspan('spannened')</pre><br>

<pre id="10tspan.clear"><span class="lnk" onmouseover="show('t(ext)span clear - очистка текстового блока')" onmouseout="hide()"><span class="shadow">tspan.</span>clear()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Очищает все содержимое вызванного элемента <tt>tspan</tt>:
<pre>// javascript
tspan.clear()</pre><br>

<pre id="10tspan.dx"><span class="lnk" onmouseover="show('t(ext)span d(ynamic)  (координата) x - динамическая координата x текстового блока')" onmouseout="hide()"><span class="shadow">tspan.</span>dx()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>

Define the dynamic `x` value of the element, much like a html element with `position:relative` and `left` defined:
<pre>// javascript
tspan.dx(30)</pre><br>

<pre id="10tspan.dy"><span class="lnk" onmouseover="show('t(ext)span d(ynamic)  (координата) y - динамическая координата y текстового блока')" onmouseout="hide()"><span class="shadow">tspan.</span>dy()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>

Define the dynamic `y` value of the element, much like a html element with `position:relative` and `top` defined:
<pre>// javascript
tspan.dy(30)</pre><br>

<pre id="10tspan.plain"><span class="lnk" onmouseover="show('t(ext)span plain - текстовый блок простого текста')" onmouseout="hide()"><span class="shadow">tspan.</span>plain()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Метод попросту добавляет в текстовый блок (<tt>tspan</tt>) обычный текст:
<pre>// javascript
tspan.plain('I do not have any expectations.')</pre><br>

<pre id="10tspan.length"><span class="lnk" onmouseover="show('t(ext)span length - длина текстового блока')" onmouseout="hide()"><span class="shadow">tspan.</span>length()</span></pre>
<div class=list>возвращает - число (<tt>number</tt>)</div>
Получает общую вычисленную длину текста текстового блока (<tt>tspan</tt>):
<pre>// javascript
tspan.length()</pre><br>

<pre id="10tspan.newLine"><span class="lnk" onmouseover="show('t(ext)span new line - новая строка (перенос строки) текстового блока')" onmouseout="hide()"><span class="shadow">tspan.</span>newLine()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

The `newLine()` is a convenience method for adding a new line with a `dy` attribute using the current "leading":
<pre>// javascript
var text = draw.text(function(add) {
  add.tspan('Lorem ipsum dolor sit amet ').newLine()
  add.tspan('consectetur').fill('#f06')
  add.tspan('.')
  add.tspan('Cras sodales imperdiet auctor.').newLine().dx(20)
  add.tspan('Nunc ultrices lectus at erat').newLine()
  add.tspan('dictum pharetra elementum ante').newLine()
})</pre><br>

<pre id="10tspan.text"><span class="lnk" onmouseover="show('t(ext)span text - текст текстового блока')" onmouseout="hide()"><span class="shadow">tspan.</span>text()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

Update the content of the tspan. This can be done by either passing a string:
<pre>// javascript
tspan.text('Just a string.')</pre>

Which will basicly call the `plain()` method:

Or by passing a block to add more specific content inside the called tspan:

<pre>// javascript
tspan.text(function(add) {
  add.plain('Just plain text.')
  add.tspan('Fancy text wrapped in a tspan.').fill('#f06')
  add.tspan(function(addMore) {
    addMore.tspan('And you can doo deeper and deeper...')
  })
})</pre><br>

<pre id="10tspan.tspan"><span class="lnk" onmouseover="show('t(ext)span t(ext)span - текстовый блок в текстовом блоке')" onmouseout="hide()"><span class="shadow">tspan.</span>tspan()</span></pre>
<div class=list>возвращает - <tt>SVG.Tspan</tt></div>
Добавляет вложенный текстовый блок (<tt>tspan</tt>):
<pre>// javascript
tspan.tspan('I am a child of my parent').fill('#f06')</pre></div><br><br>


<h4 id="11">SVG.Image</h4>
<div class=blockindent><br>
<pre id="11image"><span class="lnk" onmouseover="show('image - изображение, картинка')" onmouseout="hide()">image()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Image</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
Как и предполагалось, создает изображения:
<pre>// javascript
var image = draw.image('<span class="lnk" onmouseover="show('/path/to/image.jpg - путь/к/изображению.в формате jpg<br>(формат можеть быть другим)')" onmouseout="hide()">/path/to/image.jpg</span>')</pre>
Если размеры изображения известны, можно передать их в качестве второго и третьего аргументов:
<pre>// javascript
var image = draw.image('<span class="lnk" onmouseover="show('/path/to/image.jpg - путь/к/изображению.в формате jpg<br>(формат можеть быть другим)')" onmouseout="hide()">/path/to/image.jpg</span>', 200, 300)</pre>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("image1","image2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("image2","image1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="https://jsfiddle.net/wout/25bzorm3/2/?utm_source=website&utm_medium=embed&utm_campaign=25bzorm3" target="_blank">Редактировать в JSFiddle</a></span>
<div id="image1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/logo.jpg"></div>
<div id="image2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px; overflow-y:scroll;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(500, 130)<br>
var image = draw.image('https://cdn.img42.com/4b6f5e63ac50c95fe147052d8a4db676.jpeg')
image.size(100, 100).move(20, 20)</pre></div></div><br>

<pre id="11image.load"><span class="lnk" onmouseover="show('image load - загрузка изображения')" onmouseout="hide()"><span class="shadow">image.</span>load()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Загрузку другого изображения можно выполнить с помощью метода <tt>load()</tt>.
<pre>// javascript
image.load('<span class="lnk" onmouseover="show('/path/to/another/image.jpg - путь/к/другому/изображению.в формате jpg<br>(формат можеть быть другим)')" onmouseout="hide()">/path/to/another/image.jpg</span>')</pre><br>

<pre id="11image.loaded"><span class="lnk" onmouseover="show('image loaded - загруженное изображение')" onmouseout="hide()"><span class="shadow">image.</span>loaded()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Если размеры изображения неизвестны, то понятно, что придется подождать, пока оно не станет загруженным, т.е. <tt>loaded</tt>.
<pre>// javascript
var image = draw.image('<span class="lnk" onmouseover="show('/path/to/image.jpg - путь/к/изображению.в формате jpg<br>(формат можеть быть другим)')" onmouseout="hide()">/path/to/image.jpg</span>').loaded(function(loader) {
  this.size(loader.width, loader.height)
})</pre>
Возвращаемый загрузчиком (<tt>loader</tt>) объект в качестве первого аргумента метода загрузки содержит четыре значения:<br>
&nbsp; &#9679; &nbsp; <tt>width</tt> - ширина<br>
&nbsp; &#9679; &nbsp; <tt>height</tt> - высота<br>
&nbsp; &#9679; &nbsp; <tt>ratio</tt> (width / height) - отношение сторон (ширина/высота)<br>
&nbsp; &#9679; &nbsp; <tt>url</tt> - url-адрес</div><br><br>


<h4 id="12">SVG.Gradient</h4>
<div class=blockindent><br>
<pre id="12gradient"><span class="lnk" onmouseover="show('gradient - градиент, цветовой переход')" onmouseout="hide()">gradient()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Gradient</tt>, который наследует от <tt>SVG.Container</tt>.</div>
Существуют линейные (<tt>linear</tt>) и радиальные (<tt>radial</tt>) градиенты. Линейный градиент создается вот так:
<pre>// javascript
var gradient = draw.gradient('linear', function(stop) {
  stop.at(0, '#333')
  stop.at(1, '#fff')
})</pre>
А вот, использование градиента на элементе:
<pre>// javascript
rect.attr({ fill: gradient })</pre>
или
<pre>// javascript
rect.fill(gradient)</pre>
Метод <tt>fill()</tt> будет вызван с экземпляром градиента, переданного в качестве закрашивания любого элемента.<br><br>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("gradient1","gradient2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("gradient2","gradient1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="https://jsfiddle.net/wout/25bzorm3/2/?utm_source=website&utm_medium=embed&utm_campaign=25bzorm3" target="_blank">Редактировать в JSFiddle</a></span>
<div id="gradient1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/gradient.png"></div>
<div id="gradient2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px; overflow-y:scroll;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(500, 130)<br>
var linear = draw.gradient('linear', function(stop) {
  stop.at(0, '#f06')
  stop.at(1, '#0f9')
})<br>
draw.rect(100, 100).move(20, 20).radius(10).fill(linear)<br>
var radial = draw.gradient('radial', function(stop) {
	stop.at(0, '#0f9')
  stop.at(1, '#f06')
})<br>
draw.rect(100, 100).move(140, 20).radius(10).fill(radial)</pre></div></div><br>
У <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Gradients" target="_blank">MDN имеется прекрасная страница</a> с примерами работы градиентов SVG.
Вот <a href="https://developer.mozilla.org/ru/docs/Web/SVG/Tutorial/Gradients" target="_blank">она на русском языке</a>.<br><br>

<pre id="12gradient.at"><span class="lnk" onmouseover="show('gradient at - градиент на')" onmouseout="hide()"><span class="shadow">gradient.</span>at()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Параметры <tt>offset</tt> (смещение) и <tt>color</tt> (цвет) обязательны для граничных значений цвета (стопов - <tt>stop</tt>), параметр <tt>opacity</tt> (непрозрачность) - дополнительный, необязательный.
Смещение (<tt>offset</tt>) представляет собой число с плавающей запятой в пределах от <tt>0</tt> до <tt>1</tt> или значение в процентах (например, <tt>33%</tt>).
<pre>// javascript
stop.at(0, '#333')</pre>
или
<pre>// javascript
stop.at({ offset: 0, color: '#333', opacity: 1 })</pre><br>

<pre id="12gradient.fill"><span class="lnk" onmouseover="show('gradient fill - заполнение градиента')" onmouseout="hide()"><span class="shadow">gradient.</span>fill()</span></pre>
<div class=list>возвращает - строковое значение (<tt>string</tt>)</div>
<pre>// javascript
gradient.fill() // -> returns 'url(#SvgjsGradient1234)'</pre><br>

<pre id="12gradient.from"><span class="lnk" onmouseover="show('gradient from - градиент от')" onmouseout="hide()"><span class="shadow">gradient.</span>from()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Для определения направления перехода цвета можно установить от (<tt>from</tt>) <tt>x, y</tt> и до (<tt>to</tt>) <tt>x, y</tt>:
<pre>// javascript
gradient.from(0, 0).to(0, 1)</pre>
Значения <tt>from</tt> и <tt>to</tt> также можно выразить в процентах.<br><br>

<pre id="12gradient.get"><span class="lnk" onmouseover="show('gradient get - получить градиент')" onmouseout="hide()"><span class="shadow">gradient.</span>get()</span></pre>
<div class=list>возвращает - <tt>SVG.Stop</tt></div>
Метод <tt>get()</tt> упрощает получение стопового цвета из существующего градиента:
<pre>// javascript
var gradient = draw.gradient('radial', function(stop) {
  stop.at({ offset: 0, color: '#000', opacity: 1 })   // -> first (первый)
  stop.at({ offset: 0.5, color: '#f03', opacity: 1 }) // -> second (второй)
  stop.at({ offset: 1, color: '#066', opacity: 1 })   // -> third (третий)
})<br>
var s1 = gradient.get(0) // -> returns "first" stop (возвращает первый стоповый цвет)</pre><br>

<pre id="12gradient.radius"><span class="lnk" onmouseover="show('gradient radius - радиус градиента')" onmouseout="hide()"><span class="shadow">gradient.</span>radius()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Для определения внешнего радиуса, до которого должен распространяться внутренний цвет, у радиальных градиентов имеется метод <tt>radius()</tt>:
<pre>// javascript
var gradient = draw.gradient('radial', function(stop) {
  stop.at(0, '#333')
  stop.at(1, '#fff')
})<br>
gradient.from(0.5, 0.5).to(0.5, 0.5).radius(0.5)</pre><br>

<pre id="12gradient.to"><span class="lnk" onmouseover="show('gradient to - градиент до')" onmouseout="hide()"><span class="shadow">gradient.</span>to()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Для определения направления перехода цвета можно установить от (<tt>from</tt>) <tt>x, y</tt> и до (<tt>to</tt>) <tt>x, y</tt>:
<pre>// javascript
gradient.from(0, 0).to(0, 1)</pre>
Значения <tt>from</tt> и <tt>to</tt> также можно выразить в процентах.<br><br>

<pre id="12gradient.update"><span class="lnk" onmouseover="show('gradient update - обновление градиента')" onmouseout="hide()"><span class="shadow">gradient.</span>update()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
В дальнейшем, градиент также может быть обновлен:
<pre>// javascript
gradient.update(function(stop) {
  stop.at(0.1, '#333', 0.2)
  stop.at(0.9, '#f03', 1)
})</pre>
И даже можно отдельно обновить один стоповый цвет:
<pre>// javascript
var s1, s2, s3<br>
draw.gradient('radial', function(stop) {
  s1 = stop.at(0, '#000')
  s2 = stop.at(0.5, '#f03')
  s3 = stop.at(1, '#066')
})<br>
s1.update(0.1, '#0f0', 1)</pre></div><br><br>


<h4 id="13">SVG.Stop</h4>
<div class=blockindent><br>
<pre id="13at"><span class="lnk" onmouseover="show('at - предлог на, в')" onmouseout="hide()">at()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Gradient</tt></div>
<div class=list>возвращает - <tt>SVG.Stop</tt>, который наследует от <tt>SVG.Element</tt>.</div>
Элементы <tt>stop</tt> доступны только внутри элементов градиента.
(элемент <tt>stop</tt> (стоповый цвет) - промежуточный цвет градиента.)
<pre>// javascript
var stop = gradient.at(0.5, '#f03')</pre>
или
<pre>// javascript
var stop = gradient.at({ offset: 0.5, color: '#f06', opacity: 1 })</pre><br>

<pre id="13stop.update"><span class="lnk" onmouseover="show('stop update - обновление стопового цвета')" onmouseout="hide()"><span class="shadow">stop.</span>update()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Принимает теже параметры, что и конструктор.
<pre>// javascript
stop.update(0, '#333')</pre>
или
<pre>// javascript
stop.update({ offset: 0, color: '#333', opacity: 1 })</pre></div><br><br>


<h4 id="14">SVG.Pattern</h4>
<div class=blockindent><br>
<pre id="14pattern"><span class="lnk" onmouseover="show('pattern - шаблон, образец, паттерн')" onmouseout="hide()">pattern()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Pattern</tt>, который наследует от <tt>SVG.Container</tt>.</div>
Создание шаблона очень похоже на создание градиента:
<pre>// javascript
var pattern = draw.pattern(20, 20, function(add) {
  add.rect(20,20).fill('#f06')
  add.rect(10,10)
  add.rect(10,10).move(10,10)
})</pre>
Этим кодом создается клетчатый шаблон <tt>20&#215;20</tt> пикселей. В шаблон можно добавлять любой доступный элемент.<br>
Наконец, код для использования шаблона на элементе:
<pre>// javascript
rect.attr({ fill: pattern })</pre>
или
<pre>// javascript
rect.fill(pattern)</pre>

By passing the pattern instance as the fill on any element, the `fill()` method will be called on the pattern instance.<br><br>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("pattern1","pattern2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("pattern2","pattern1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="http://jsfiddle.net/wout/jckwhha7/?utm_source=website&utm_medium=embed&utm_campaign=jckwhha7" target="_blank">Редактировать в JSFiddle</a></span>
<div id="pattern1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/pattern.png"></div>
<div id="pattern2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(500, 130)<br>
var pattern = draw.pattern(20, 20, function(add) {
  add.rect(20,20).fill('#f06')
  add.rect(10,10).fill('#0f9')
  add.rect(10,10).move(10,10).fill('#fff')
})<br>
draw.rect(100, 100).move(20, 20).radius(10).fill(pattern)</pre></div></div><br>

<pre id="14pattern.fill"><span class="lnk" onmouseover="show('pattern fill - заливка шаблона')" onmouseout="hide()"><span class="shadow">pattern.</span>fill()</span></pre>
<div class=list>возвращает - строковое значение (<tt>string</tt>)</div>
<pre>// javascript
pattern.fill() // -> returns 'url(#SvgjsPattern1234)'</pre><br>

<pre id="14pattern.update"><span class="lnk" onmouseover="show('pattern update - обновление шаблона')" onmouseout="hide()"><span class="shadow">pattern.</span>update()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
В дальнейшем шаблон также может обновляться:
<pre>// javascript
pattern.update(function(add) {
  add.circle(15).center(10,10)
})</pre></div><br><br>


<h4 id="15">SVG.Mask</h4>
<div class=blockindent><br>
<pre id="15mask"><span class="lnk" onmouseover="show('mask - маска')" onmouseout="hide()">mask()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Mask</tt>, который наследует от <tt>SVG.Container</tt>.</div>
<pre>// javascript
var ellipse = draw.ellipse(80, 40).move(10, 10).fill('#fff')<br>
var mask = draw.mask().add(ellipse)<br>
rect.maskWith(mask)</pre>
Но также можно использовать несколько элементов:
<pre>// javascript
var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })
var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 }).fill({ color: '#fff' })<br>
var mask = draw.mask().add(text).add(ellipse)<br>
rect.maskWith(mask)</pre><br>
<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("mask1","mask2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("mask2","mask1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="http://jsfiddle.net/wout/s5mb5zds/1/?utm_source=website&utm_medium=embed&utm_campaign=s5mb5zds" target="_blank">Редактировать в JSFiddle</a></span>
<div id="mask1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/mask.png"></div>
<div id="mask2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px; overflow-y:scroll;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(300, 130)
var circle = draw.circle(50).fill('#fff')<br>
var mask = draw.mask()
mask.add(circle.center(35, 35))
mask.add(circle.clone().center(70, 70).size(70).fill('#ccc'))
mask.add(circle.clone().center(90, 30).size(30).fill('#999'))
mask.add(circle.clone().center(105, 115).size(50).fill('#333'))<br>
var rect = draw.rect(100, 100).move(20, 20).fill('#f06')
rect.maskWith(mask)<br>
rect.on('mouseover', function() {
	this.animate(300, '&#60;&#62;').fill('#0f9')
})
rect.on('mouseout', function() {
	this.animate(300, '&#60;&#62;').fill('#f06')
})</pre></div></div>
<div class=caption>Здесь не видно анимации при наведении курсора мышки. Для полноценного просмотра перейдите на <a href="http://jsfiddle.net/wout/s5mb5zds/1/?utm_source=website&utm_medium=embed&utm_campaign=s5mb5zds" target="_blank">JSFiddle</a>.</div><br>

<pre id="15maskWith"><span class="lnk" onmouseover="show('mask with - маска с')" onmouseout="hide()">maskWith()</span></pre>
<div class=list>конструктор на <tt>SVG.Element</tt></div>
<div class=list>возвращает - самого себя (itself)</div>
Самый простой способ наложения маски - использовать один элемент:
<pre>// javascript
var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: '#fff' })<br>
rect.maskWith(ellipse)</pre>
Если вы хотите, чтобы маскируемый объект отображался на 100%, вам нужно установить цвет заливки маскирующего объекта на белый. Но также можно использовать градиент:
<pre>// javascript
var gradient = draw.gradient('linear', function(stop) {
  stop.at({ offset: 0, color: '#000' })
  stop.at({ offset: 1, color: '#fff' })
})<br>
var ellipse = draw.ellipse(80, 40).move(10, 10).fill({ color: gradient })<br>
rect.maskWith(ellipse)</pre><br>

<pre id="15mask.unmask"><span class="lnk" onmouseover="show('mask unmask - снять маску')" onmouseout="hide()"><span class="shadow">mask.</span>unmask()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Снять маску с элементов можно методом <tt>unmask()</tt>:
<pre>// javascript
rect.unmask()</pre>
Метод <tt>unmask()</tt> возвращает маскирующий элемент.<br><br>

<pre id="15mask.remove"><span class="lnk" onmouseover="show('mask remove - удалить маску')" onmouseout="hide()"><span class="shadow">mask.</span>remove()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Полное удаление маски также приведет к снятию маски (метод <tt>unmask()</tt>) со всех замаскированных элементов:
<pre>// javascript
mask.remove()</pre><br>

<pre id="15masker"><span class="lnk" onmouseover="show('masker - замаскированный элемент')" onmouseout="hide()">masker</span></pre>
<div class=list>возвращает - <tt>SVG.Mask</tt>.</div>
Для удобства использования на маскирующий элемент также ссылаются в маскированном элементе. Это может пригодиться, если понадобится изменить маску:
<pre>// javascript
rect.masker.fill('#fff')</pre></div><br><br>


<h4 id="16">SVG.ClipPath</h4>
Элементы обрезки работают точно так же, как маскирующие элементы. Различие заключается только в том, что обрезываемые элементы будут принимать геометрию элемента обрезки.
Поэтому события запускаются только при вводе элемента обрезки, в то время как при маскировании запускает событие сам маскирующий элемент.
Другое отличие состоит в том, что маски могут устанавливать непрозрачность их цвета заливки, а элементы обрезки не могут.
<div class=blockindent><br>
<pre id="16clip"><span class="lnk" onmouseover="show('clip - вырезка, отсечение')" onmouseout="hide()">clip()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.ClipPath</tt>, который наследует от <tt>SVG.Container</tt>.</div>
Обрезка нескольких элементов:
<pre>// javascript
var ellipse = draw.ellipse(80, 40).move(10, 10)
var text = draw.text('SVG.JS').move(10, 10).font({ size: 36 })<br>
var clip = draw.clip().add(text).add(ellipse)<br>
rect.clipWith(clip)</pre><br>

<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("clip1","clip2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("clip2","clip1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="http://jsfiddle.net/wout/6g9pfr2m/1/?utm_source=website&utm_medium=embed&utm_campaign=6g9pfr2m" target="_blank">Редактировать в JSFiddle</a></span>
<div id="clip1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/clip.png"></div>
<div id="clip2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px; overflow-y:scroll;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing').size(300, 130)
var circle = draw.circle(50).fill('#fff')<br>
var clip = draw.clip()
clip.add(circle.center(35, 35))
clip.add(circle.clone().center(70, 70).size(70).fill('#ccc'))
clip.add(circle.clone().center(90, 30).size(30).fill('#999'))
clip.add(circle.clone().center(105, 115).size(50).fill('#333'))<br>
var rect = draw.rect(100, 100).move(20, 20).fill('#f06')
rect.clipWith(clip)<br>
rect.on('mouseover', function() {
	this.animate(300, '&#60;&#62;').fill('#0f9')
})
rect.on('mouseout', function() {
	this.animate(300, '&#60;&#62;').fill('#f06')
})</pre></div></div><br>

<pre id="16clipWith"><span class="lnk" onmouseover="show('clip with - обрезка с')" onmouseout="hide()">clipWith()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<pre>// javascript
var ellipse = draw.ellipse(80, 40).move(10, 10)<br>
rect.clipWith(ellipse)</pre><br>

<pre id="16clipPath.unclip"><span class="lnk" onmouseover="show('clip path unclip - удалить контур обрезки')" onmouseout="hide()"><span class="shadow">clipPath.</span>unclip()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
С помощью метода <tt>unclip()</tt> можно убрать обрезку элементов:
<pre>// javascript
rect.unclip()</pre><br>

<pre id="16clipPath.remove"><span class="lnk" onmouseover="show('clip path remove - удалить путь обрезки')" onmouseout="hide()"><span class="shadow">clipPath.</span>remove()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Полное удаление обрезки также приведет к удалению обрезки (метод <tt>unclip()</tt>) со всех обрезанных элементов:
<pre>// javascript
clip.remove()</pre><br>

<pre id="16clipper"><span class="lnk" onmouseover="show('clipper - ножницы')" onmouseout="hide()">clipper</span></pre>
<div class=list>возвращает - <tt>SVG.ClipPath</tt>.</div>
Для удобства использования на обрезывающий элемент также ссылаются в обрезанном элементе. Это может пригодиться, если понадобится изменить <tt>clipPath</tt> - контур обрезки:
<pre>// javascript
rect.clipper.move(10, 10)</pre></div><br><br>


<h4 id="17">SVG.Use</h4>
<div class=blockindent><br>
<pre id="17use"><span class="lnk" onmouseover="show('use - использовать, применять')" onmouseout="hide()">use()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Use</tt>, который наследует от <tt>SVG.Shape</tt>.</div>
Элемент <tt>SVG.Use</tt> попросту эмулирует другой, уже существующий элемент. Любые изменения элемента-образца будут отражены во всех экземплярах, созданных с помощью метода <tt>use()</tt>.<br>
Использовать метод <tt>use()</tt> очень просто:
<pre>// javascript
var rect = draw.rect(100, 100).fill('#f09')
var use  = draw.use(rect).move(200, 200)</pre>
В приведенном выше примере на рисунке svg появятся два прямоугольника: исходный (<tt>rect</tt>) и экземпляр (<tt>use</tt>), созданный с помощью метода <tt>use()</tt>.
В некоторых случаях может понадобиться скрыть исходный элемент. Лучший способ сделать это — создать исходный элемент в <a href="parents.htm#5" onmouseover="show('SVG.Defs')" onmouseout="hide()">узле определений</a>:
<pre>// javascript
var rect = draw.defs().rect(100, 100).fill('#f09')
var use  = draw.use(rect).move(200, 200)</pre>
Таким образом, данный элемент <tt>rect</tt> действует как библиотечный элемент. Его можно редактировать, но отображаться он не будет.<br><br>
Другой способ - задать элемент во внешнем SVG-файле, нужно просто указать идентификатор (<tt>id</tt>) элемента и путь к файлу.
<pre>// javascript
var use  = draw.use('elementId', 'path/to/file.svg')</pre>
Такой способ хорош, когда уже имеются созданные сложные изображения.
Обратите внимание, что для внешних изображений (за пределами вашего домена) может потребоваться загрузка файла с <a href="https://ru.wikipedia.org/wiki/XMLHttpRequest" target="_blank" onmouseover="show('XMLHttpRequest (XMLHTTP, XHR) — API, доступный в скриптовых<br>языках браузеров, таких как JavaScript. Использует запросы HTTP<br>или HTTPS напрямую к веб-серверу и загружает данные ответа<br>сервера напрямую в вызывающий скрипт.<br>Информация может передаваться в любом текстовом формате,<br>например, в XML, HTML или JSON. Позволяет осуществлять<br>HTTP-запросы к серверу без перезагрузки страницы.')" onmouseout="hide()">XHR</a>.
Вот статья <a href="https://learn.javascript.ru/ajax-xmlhttprequest" target="_blank">"Основы XMLHttpRequest"</a> от javascript.ru.</div><br><br>


<h4 id="18">SVG.Marker</h4>
<div class=blockindent><br>
<pre id="18marker"><span class="lnk" onmouseover="show('marker - маркер, метка, знак')" onmouseout="hide()">marker()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Marker</tt>, который наследует от <tt>SVG.Container</tt>.</div>
Маркеры можно добавлять к любой отдельной точке <tt>line</tt>, <tt>polyline</tt>, <tt>polygon</tt> и <tt>path</tt>.
Существует три типа маркеров: <tt><span class="lnk" onmouseover="show('start - начало, старт')" onmouseout="hide()">start</span></tt>,
<tt><span class="lnk" onmouseover="show('mid - середина, сокращ. от middle')" onmouseout="hide()">mid</span></tt> и <tt><span class="lnk" onmouseover="show('end - конец')" onmouseout="hide()">end</span></tt>.
Где <tt>start</tt> представляет первую точку, <tt>end</tt> - последнюю, а <tt>mid</tt> - любая из точек между ними.
<pre>// javascript
var path = draw.path('M0 0 A50 50 0 0 1 50 50 A50 50 0 0 0 100 100')<br>
path.fill('none').move(20, 20).stroke({ width: 1, color: '#ccc' })<br>
path.marker('start', 10, 10, function(add) {
  add.circle(10).fill('#f06')
})
path.marker('mid', 10, 10, function(add) {
  add.rect(5, 10).cx(5).fill('#ccc')
})
path.marker('end', 20, 20, function(add) {
  add.circle(6).center(4, 5)
  add.circle(6).center(4, 15)
  add.circle(6).center(12, 10)<br>
  this.fill('#0f9')
})</pre>
Метод <tt>marker()</tt> можно использовать тремя способами. Во-первых, маркер можно создать на любом элементе - контейнере (например, <tt>svg</tt>, <tt>nested</tt>, <tt>group</tt>, <tt>...</tt>).
Это полезно, если планируется многократно использовать маркер, так что маркер будет создан в определениях, но пока не будет показан:
<pre>// javascript
var marker = draw.marker(10, 10, function(add) {
  add.rect(10, 10)
})</pre>
Во-вторых, маркер может быть создан и применен непосредственно на его целевом элементе:
<pre>// javascript
path.marker('start', 10, 10, function(add) {
  add.circle(10).fill('#f06')
})</pre>
Этот код создаст маркер в определениях и сразу применит его. Отметьте, что первый аргумент определяет позицию маркера и что, имеется четыре аргумента, в отличие от трех в первом примере.<br><br>
Последний вариант, если маркер создан для переиспользования на элементе-контейнере, он может быть напрямую применен к целевому элементу:
<pre>// javascript
path.marker('mid', marker)</pre>
Наконец, для получения экземпляра маркера из ссылки на целевой элемент:
<pre>// javascript
path.reference('marker-end')</pre>

<div style="font-family:Segoe UI; font-size:90%; margin-left:10px;">
&nbsp; &nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("marker1","marker2");'>Результат</span>
&nbsp; &nbsp; <span class="lnk" onclick='javascript:show_img("marker2","marker1");'>Код JavaScript</span>
<span style="float:right; margin-right:20px;"><a href="http://jsfiddle.net/wout/j3fr5okk/?utm_source=website&utm_medium=embed&utm_campaign=j3fr5okk" target="_blank">Редактировать в JSFiddle</a></span>
<div id="marker1" style="height:220px; background-color:#fff; display:block; margin:0px; padding:0px;">
<hr class="underline" style="margin-left:20px; width:60px;">
<img src="img/marker.png"></div>
<div id="marker2" style="height:220px; background-color:#eee; display:none; margin:0px; padding:0px; overflow-y:scroll;">
<hr class="underline" style="margin-left:100px; width:80px;">
<pre>var draw = SVG('drawing')<br>
var path = draw.path('M0 0 A50 50 0 0 1 50 50 A50 50 0 0 0 100 100')<br>
path.fill('none').move(20, 20).stroke({ width: 1, color: '#ccc' })<br>
path.marker('start', 10, 10, function(add) {
  add.circle(10).fill('#f06')
})
path.marker('mid', 10, 10, function(add) {
  add.rect(5, 10).cx(5).fill('#ccc')
})
path.marker('end', 20, 20, function(add) {
  add.circle(6).center(4, 5)
  add.circle(6).center(4, 15)
  add.circle(6).center(12, 10)<br>
  this.fill('#0f9')
})</pre></div></div><br>

<pre id="18marker.height"><span class="lnk" onmouseover="show('marker height - высота маркера')" onmouseout="hide()"><span class="shadow">marker.</span>height()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод определяет атрибут <tt><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerHeight" target="_blank" onmouseover="show('markerHeight представляет высоту области просмотра, в которую<br>при отображении должен быть вставлен <marker>.<br>Нулевое значение отключает отображение элемента.<br>Если атрибут не указан, эффект будет таким, как если бы было<br>указано значение 3.')" onmouseout="hide()">markerHeight</a></tt>:
<pre>// javascript
marker.height(10)</pre><br>

<pre id="18marker.ref"><span class="lnk" onmouseover="show('marker refer - относительно маркера')" onmouseout="hide()"><span class="shadow">marker.</span>ref()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=note_trans><b>Примечание переводчика:</b> Атрибуты <tt>refX</tt> и <tt>refY</tt> используются для представления координат местоположения на маркере, где он будет присоединен к, отмечаемому им, элементу. Эти координаты даются относительно системы координат маркера, а не к маркируемому элементу, на который он помещен.</div>
По умолчанию, атрибуты маркера <tt>refX</tt> и <tt>refY</tt> устанавливаются как половинные значения <tt>width</tt> (ширины) и <tt>height</tt> (высоты) маркера.<br>
Для определения <tt>refX</tt> и <tt>refY</tt> маркера по отдельности:
<pre>// javascript
marker.ref(2, 7)</pre><br>

<pre id="18marker.size"><span class="lnk" onmouseover="show('marker size - размер маркера')" onmouseout="hide()"><span class="shadow">marker.</span>size()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод определяет атрибуты <tt><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerWidth" target="_blank" onmouseover="show('markerWidth представляет ширину области просмотра, в которую<br>при отображении должен быть вставлен <marker>.<br>Нулевое значение отключает отображение элемента.<br>Если атрибут не указан, эффект будет таким, как если бы было<br>указано значение 3.')" onmouseout="hide()">markerWidth</a></tt>
и <tt><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerHeight" target="_blank" onmouseover="show('markerHeight представляет высоту области просмотра, в которую<br>при отображении должен быть вставлен <marker>.<br>Нулевое значение отключает отображение элемента.<br>Если атрибут не указан, эффект будет таким, как если бы было<br>указано значение 3.')" onmouseout="hide()">markerHeight</a></tt>:
<pre>// javascript
marker.size(10, 10)</pre><br>

<pre id="18marker.update"><span class="lnk" onmouseover="show('marker update - обновление маркера')" onmouseout="hide()"><span class="shadow">marker.</span>update()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Обновление содержимого маркера "очистит" (т.е. сначала будет применен метод <tt>clear()</tt>) существующий контент и добавит содержимое, определенное в блоке, переданнов в качестве первого аргумента:
<pre>// javascript
marker.update(function(add) {
  add.circle(10)
})</pre><br>

<pre id="18marker.width"><span class="lnk" onmouseover="show('marker width - ширина маркера')" onmouseout="hide()"><span class="shadow">marker.</span>width()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод определяет атрибут <tt><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerWidth" target="_blank" onmouseover="show('markerWidth представляет ширину области просмотра, в которую<br>при отображении должен быть вставлен <marker>.<br>Нулевое значение отключает отображение элемента.<br>Если атрибут не указан, эффект будет таким, как если бы было<br>указано значение 3.')" onmouseout="hide()">markerWidth</a></tt>:
<pre>// javascript
marker.width(10)</pre></div><br><br>


<h4 id="19">SVG.Bare</h4>
<div class=note_trans><b>Примечание переводчика:</b> "bare" в переводе значит пустой, голый.</div>
Для всех SVG элементов, не указанных в SVG.js, пригодится класс <tt>SVG.Bare</tt>.
Этот класс наследуется непосредственно от <tt>SVG.Element</tt> и позволяет добавлять пользовательские методы в отдельное пространство имен (namespace) без загрязнения основного пространства имен <tt>SVG.Element</tt>.
Считайте, что это ваша личная "игровая площадка".
<div class=blockindent><br>
<pre id="19element"><span class="lnk" onmouseover="show('element - элемент, звено, составная часть')" onmouseout="hide()">element()</span>  <i class=low>конструктор</i></pre>
<div class=list>возвращает - <tt>SVG.Bare</tt>, который наследует от <tt>SVG.Element</tt>.</div>
При помощи метода <tt>element()</tt> может быть создан класс <tt>SVG.Bare</tt> для любого родительского элемента:
<pre>// javascript
var element = draw.element('title')</pre>
Передаваемое в качестве первого аргумента, строковое значение является именем создаваемого узла.<br>
Кроме того, в качестве второго аргумента можно передать любое существующее имя класса для определения, из какого класса должен наследовать элемент:
<pre>// javascript
var element = draw.element('symbol', SVG.Parent)</pre>
Это дает пользователю большую силу. Но помните, с большой силой приходит и большая ответственность.<br><br>

<pre id="19element.get"><span class="lnk" onmouseover="show('element words - слова элемента')" onmouseout="hide()"><span class="shadow">element.</span>words()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Экземпляр <tt>SVG.Bare</tt> содержит дополнительный метод для добавления простого текста:
<pre>// javascript
var element = draw.element('title').words('This is a title.')
// -> &#60;title&#62;This is a title.&#60;/title&#62;</pre></div><br><br>

<br><br>
</body></html>
