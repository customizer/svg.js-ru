<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>svg.js Справочное руководство</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>

<body>
<h3 id="1">Анимация</h3>
Анимация элементов очень похожа на управление элементами с помощью метода <tt>attr()</tt>. Отличие только в том, что нужно включать метод <tt>animate()</tt>.<br><br>

<h5>Цепочки методов</h5>
Обратите внимание, что метод <tt>animate()</tt> не будет возвращать целевой элемент, а возвратит экземпляр <tt>SVG.FX</tt>, который будет использовать следующие методы:<br>
Конечно же <tt>attr()</tt>:
<pre>// javascript
rect.animate().attr({ fill: '#f03' })</pre>
Методы <tt>x()</tt>, <tt>y()</tt> и <tt>move()</tt>:
<pre>// javascript
rect.animate().move(100, 100)</pre>
А также методы <tt>cx()</tt>, <tt>cy()</tt> и <tt>center()</tt>:
<pre>rect.animate().center(200, 200)</pre>
Или методы преобразования:
<pre>// javascript
rect.animate().rotate(45).skew(25, 0)</pre>

You can also animate non-numeric unit values using the `attr()` method:
<pre>// javascript
rect.attr('x', '10%').animate().attr('x', '50%')</pre><br>

<h5>Упрощение</h5>
All available ease types are:

<div class=list> <tt>&#60;&#62;</tt> - упрощение <tt>in</tt> и <tt>out</tt></div>
<div class=list> <tt>&#62;</tt> - ease <tt>out</tt></div>
<div class=list> <tt>&#60;</tt> - ease <tt>in</tt></div>
<div class=list> <tt>-</tt> - linear</div>
<div class=list> <tt>=</tt> - external control</div>
<div class=list> <tt>a</tt> - функция</div>

For the latter, here is an example of the default `&#60;&#62;` function:

<pre>// javascript
function(pos) { return (-Math.cos(pos * Math.PI) / 2) + 0.5 }</pre>

For more easing equations, have a look at the (link: https://github.com/svgdotjs/svg.easing.js text: svg.easing.js target: _blank) plugin.<br><br>

<h4>animate()</h4>

`returns` __`SVG.FX`__

<pre>// javascript
rect.animate().move(150, 150)</pre>

The `animate()` method will take three arguments. The first is `duration`, the second `ease` and the third `delay`:

<pre>// javascript
rect.animate(2000, '>', 1000).attr({ fill: '#f03' })</pre>


Alternatively you can pass an object as the first argument:

<pre>// javascript
rect.animate({ ease: '&#60;', delay: '1.5s' }).attr({ fill: '#f03' })</pre>

By default `duration` will be set to `1000`, `ease` will be set to `&#60;&#62;`.

You can chain multiple animations together by calling `animate` again:

<pre>// javascript
rect.animate({ ease: '&#60;', delay: '1.5s' }).attr({ fill: '#f03' }).animate().dmove(50,50)</pre><br>

<h4>situation</h4>

`returns` __`object`__

The current situation of an animation is stored in the `situation` object:

<pre>// javascript
rect.animate(3000).move(100, 100)
rect.fx.situation //-> everything is in here</pre>

Available values are:

<div class=list> <tt>start</tt> (start time as a number in milliseconds)</div>
<div class=list> <tt>play</tt> (animation playing or not; `true` or `false`)</div>
<div class=list> <tt>pause</tt> (time when the animation was last paused)</div>
<div class=list> <tt>duration</tt> (the chosen duration of the animation)</div>
<div class=list> <tt>ease</tt> (the chosen easing calculation)</div>
<div class=list> <tt>finish</tt> (start + duration)</div>
<div class=list> <tt>loop</tt> (the current loop; counting down if a number; `true`, `false` or a number)</div>
<div class=list> <tt>loops</tt> (if a number, the total number loops; `true`, `false` or a number)</div>
<div class=list> <tt>reverse</tt> (whether or not the animation should run backwards)</div>
<div class=list> <tt>reversing</tt> (<tt>true</tt> if the loop is currently reversing, otherwise <tt>false</tt>)</div><br>

<h4>target()</h4>

`returns` __`SVG.Element`__

The target method returns the element the animation is applied to:

<pre>// javascript
rect.fx.target() // returns rect</pre><br>

# Controlling

## finish()

`returns` __`itself`__

This method finishes the whole animation chain. All values are set to their corresponding end values and every situation gets fullfilled

<pre>// javascript
rect.animate().move(200, 200).animate().dmove(50,50).size(300,400)

rect.finish() // rect at 250,250 with size 300,400</pre><br>

## pause()

`returns` __`itself`__

Pausing an animations is fairly straightforward:
<pre>// javascript
rect.animate().move(200, 200)

rect.mouseover(function() { this.pause() })</pre><br>

## play()

`returns` __`itself`__

Will start playing a paused animation:

<pre>// javascript
rect.animate().move(200, 200)

rect.mouseover(function() { this.pause() })
rect.mouseout(function() { this.play() })</pre><br>

## reverse()

`returns` __`itself`__

Toggles the direction of the animation or sets it to a specific direction:

<pre>// javascript
// will run from 100,100 to rects initial position
rect.animate(3000).move(100, 100).reverse()

// sets direction to backwards
rect.animate(3000).move(100, 100).reverse(true)

// sets direction to forwards (same as not calling reverse ever)
rect.animate(3000).move(100, 100).reverse(false)</pre><br>

## stop()

`returns` __`itself`__

If you just want to stop an animation you can call the `stop()` method which has two optional arguments:

 - jumpToEnd: Sets the values to the end of the animation
 - clearQueue: Remove all items from queue

<pre>// javascript
rect.animate().move(200, 200)

rect.stop()
// or e.g.
rect.stop(true)</pre>

Stopping an animation is irreversible.<br><br>

# Timing

## at()

`returns` __`itself`__

Say you want to control the position of an animation with an external event, then the `at()` method will prove very useful:

<pre>// javascript
var animation = draw.rect(100, 100).move(50, 50).animate('=').move(200, 200)

document.onmousemove = function(event) {
  animation.at(event.clientX / 1000)
}</pre>

The value passed as the first argument of `at()` should be a number between `0` and `1`, `0` being the beginning of the animation and `1` being the end. Note that any values below `0` and above `1` will be normalized.

Also note that the value is eased after calling the function. Therefore the position specifies a position in time not in space.<br><br>

## delay()

`returns` __`itself`__

Alternatively, you can call `delay()` which will set a delay in ms before the next animation in the queue is run

<pre>// javascript
rect.animate({ ease: '&#60;', delay: '1.5s' }).attr({ fill: '#f03' }).delay(500).animate().dmove(50,50)</pre><br>

## loop()

`returns` __`SVG.FX`__

By default the `loop()` method creates and eternal loop:
<pre>// javascript
rect.animate(3000).move(100, 100).loop()</pre>

But the loop can also be a predefined number of times:
<pre>// javascript
rect.animate(3000).move(100, 100).loop(3)</pre>

Loops go from beginning to end and start over again (`0->1.0->1.0->1.`).

There is also a reverse flag that should be passed as the second argument:

<pre>// javascript
rect.animate(3000).move(100, 100).loop(3, true)</pre>

Loops will then be completely reversed before starting over (`0->1->0->1->0->1.`).<br><br>

## once()

`returns` __`itself`__

Finally, you can perform an action at a specific position only once. Just pass the position and the function which should be executed to the `once` method. You can also decide whether the position which is passed should be handled as position in time (not eased) or position in space (easing applied):

<pre>// javascript
// the 0.5 is handled as uneased value (you can omit the false)
rect.animate(3000).move(100, 100).once(0.5, function(pos, eased) {
  // do something
}, false)<pre>// javascript

<pre>// javascript
// the 0.5 is handled as eased value
rect.animate(3000).move(100, 100).once(0.5, function(pos, eased) {
  // do something
}, true)</pre>

The callback function gets the current position uneased and eased.<br><br>

## queue()

`returns` __`itself`__

If you want to call a custom funtion between two chained animations, you simply can queue them up:

<pre>// javascript
rect.animate({ ease: '&#60;', delay: '1.5s' }).attr({ fill: '#f03' }).queue(function(){

    this.target().fill('#000')
    this.dequeue() // dont forget to call dequeue when the queue should continue running

}).animate().dmove(50,50)</pre><br><br>


# Callbacks

## after / afterAll()

`returns` __`itself`__

Furthermore, you can add callback methods using `after()/afterAll()`:

<pre>// javascript
rect.animate(3000).move(100, 100).after(function(situation) {
  this.animate().attr({ fill: '#f06' })
})

// or
rect.animate(3000).move(100, 100).afterAll(function() {
  this.animate().attr({ fill: '#f06' })
})</pre>

The function gets the situation which was finished as first parameter. This doesn't apply to afterAll where no parameter is passed
Note that the `after()/afterAll()` method will never be called if the animation is looping eternally.
You can call `after()/afterAll()` multiple times to add more functions which should be executed.<br><br>

## during / duringAll()

`returns` __`itself`__

If you want to perform your own actions during one/all animation you can use the `during()/duringAll()` method:

<pre>// javascript
var position
  , from = 100
  , to   = 300

rect.animate(3000).move(100, 100).during(function(pos, morph, eased, situation) {
  position = from + (to - from) * pos
})

// or
rect.animate(3000).move(100, 100).duringAll(function(pos, morph, eased, situation) {
  position = from + (to - from) * pos
})</pre>

Note that `pos` is `0` in the beginning of the animation and `1` at the end of the animation.<br>

To make things easier a morphing function is passed as the second argument. This function accepts a `from` and `to` value as the first and second argument and they can be a number, unit or hex color:

<pre>// javascript
var ellipse = draw.ellipse(100, 100).attr('cx', '20%').fill('#333')

rect.animate(3000).move(100, 100).during(function(pos, morph, eased, situation) {
  // numeric values
  ellipse.size(morph(100, 200), morph(100, 50))

  // unit strings
  ellipse.attr('cx', morph('20%', '80%'))

  // hex color strings
  ellipse.fill(morph('#333', '#ff0066'))
})</pre>
The `eased` parameter contains the position after the easing function was applied.
The last parameter holds the current situation related to the current `during` call.
You can call `during()/duringAll()` multiple times to add more functions which should be executed.

----

Description: Note that the animate() method will not return the targeted element but an instance of SVG.FX which will take the following methods.


<br><br>
</body></html>