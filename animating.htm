<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>svg.js Справочное руководство</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>

<body>
<h3 id="1">Анимация</h3>
Анимация элементов очень похожа на управление элементами с помощью метода <tt>attr()</tt>. Отличие только в том, что нужно включать метод <tt>animate()</tt>.<br><br>

<h5>Цепочки методов</h5>
Обратите внимание, что метод <tt>animate()</tt> не будет возвращать целевой элемент, а возвратит экземпляр <tt>SVG.FX</tt>, который будет использовать следующие методы:<br>
Конечно же <tt>attr()</tt>:
<pre>// javascript
rect.animate().attr({ fill: '#f03' })</pre>
Методы <tt>x()</tt>, <tt>y()</tt> и <tt>move()</tt>:
<pre>// javascript
rect.animate().move(100, 100)</pre>
А также методы <tt>cx()</tt>, <tt>cy()</tt> и <tt>center()</tt>:
<pre>rect.animate().center(200, 200)</pre>
Или методы преобразования:
<pre>// javascript
rect.animate().rotate(45).skew(25, 0)</pre>

You can also animate non-numeric unit values using the `attr()` method:
<pre>// javascript
rect.attr('x', '10%').animate().attr('x', '50%')</pre><br>

<h5>Плавность анимации</h5>
Все доступные типы плавности течения анимации:
<div class=list> <tt>&#60;&#62;</tt> - плавное начало и окончание, т.е. анимация начинается медленно, затем ускоряется и к концу движения опять замедляется</div>
<div class=list> <tt>&#62;</tt> - плавное окончание( начинается быстро, к концу замедляется)</div>
<div class=list> <tt>&#60;</tt> - плавное начало (медленно начинается, к концу ускоряется)</div>
<div class=list> <tt>-</tt> - линейная, т.е. скорость анимации одинакова от начала и до конца</div>
<div class=list> <tt>=</tt> - внешнее управление</div>
<div class=list> <tt>a</tt> - функция.</div>
Для последнего типа вот пример функции, использующейся по умолчанию - <tt>&#60;&#62;</tt>:
<pre>// javascript
function(pos) { return (-Math.cos(pos * Math.PI) / 2) + 0.5 }</pre>
Для большего числа уравнений плавности посмотрите плагин <a href="https://github.com/svgdotjs/svg.easing.js" target="_blank">svg.easing.js</a>.<br>


<div class=blockindent><br>
<pre id="1animate"><span class="lnk" onmouseover="show('animate - анимация')" onmouseout="hide()">animate()</span></pre>
<div class=list>возвращает - <tt>SVG.FX</tt></div>
<pre>// javascript
rect.animate().move(150, 150)</pre>
Метод <tt>animate()</tt> будет принимать три аргумента. Первый - <tt>duration</tt> (продолжительность), второй - <tt>ease</tt> (плавность) и третий - <tt>delay</tt> (задержка):
<pre>// javascript
rect.animate(2000, '>', 1000).attr({ fill: '#f03' })</pre>
Кроме того, можно в качестве первого аргумента передать объект:
<pre>// javascript
rect.animate({ ease: '&#60;', delay: '1.5s' }).attr({ fill: '#f03' })</pre>
По умолчанию значение для <tt>duration</tt> устанавливается как <tt>1000</tt>, для <tt>ease</tt> будет установлено <tt>&#60;&#62;</tt>.
Можно объединять несколько анимаций вместе повторным вызовом <tt>animate</tt>:
<pre>// javascript
rect.animate({ ease: '&#60;', delay: '1.5s' }).attr({ fill: '#f03' }).animate().dmove(50,50)</pre><br>

<pre id="1situation"><span class="lnk" onmouseover="show('situation - ситуация, положение, обстановка')" onmouseout="hide()">situation</span></pre>
<div class=list>возвращает - объект</div>
Текущая ситуация анимации хранится в объекте <tt>situation</tt>:
<pre>// javascript
rect.animate(3000).move(100, 100)
rect.fx.situation //-> everything is in here (все здесь)</pre>
Доступные значения:
<div class=list> <tt>start</tt> (время старта как число в миллисекундах)</div>
<div class=list> <tt>play</tt> (проигрывать анимацию или нет; значения <tt>true</tt> или <tt>false</tt>)</div>
<div class=list> <tt>pause</tt> (время, когда анимация последний раз приостанавливалась, т.е. время последней паузы)</div>
<div class=list> <tt>duration</tt> (выбранная продолжительность анимации)</div>
<div class=list> <tt>ease</tt> (выбранный расчет плавности)</div>
<div class=list> <tt>finish</tt> (<tt>start</tt> + <tt>duration</tt>)</div>
<div class=list> <tt>loop</tt> (текущий цикл; <tt>true</tt>, <tt>false</tt> или число; если число, то это обратный отсчет)</div>
<div class=list> <tt>loops</tt> (количество циклов; <tt>true</tt>, <tt>false</tt> или число; если число, то это общее количество циклов)</div>
<div class=list> <tt>reverse</tt> (должна ли анимация выполняться в обратном направлении)</div>
<div class=list> <tt>reversing</tt> (значение <tt>true</tt>, если цикл в настоящий момент реверсивный, в противном случае - <tt>false</tt>)</div><br>

<pre id="1target"><span class="lnk" onmouseover="show('target - цель')" onmouseout="hide()">target()</span></pre>
<div class=list>возвращает - <tt>SVG.Element</tt></div>
Метод <tt>target()</tt> возвращает элемент, к которому применяется анимация:
<pre>// javascript
rect.fx.target() // returns rect</pre></div><br><br>


<h3 id="2">Управление</h3>
<div class=blockindent><br>
<pre id="15finish"><span class="lnk" onmouseover="show('finish - конец, финиш')" onmouseout="hide()">finish()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

This method finishes the whole animation chain. All values are set to their corresponding end values and every situation gets fullfilled
<pre>// javascript
rect.animate().move(200, 200).animate().dmove(50,50).size(300,400)

rect.finish() // rect at 250,250 with size 300,400</pre><br>

<pre id="15pause"><span class="lnk" onmouseover="show('pause - пауза, перерыв, приостановка')" onmouseout="hide()">pause()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

Pausing an animations is fairly straightforward:
<pre>// javascript
rect.animate().move(200, 200)<br>
rect.mouseover(function() { this.pause() })</pre><br>

<pre id="15play"><span class="lnk" onmouseover="show('play - воспроизведение, исполнение, игра')" onmouseout="hide()">play()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

Will start playing a paused animation:
<pre>// javascript
rect.animate().move(200, 200)<br>
rect.mouseover(function() { this.pause() })
rect.mouseout(function() { this.play() })</pre><br>

<pre id="15reverse"><span class="lnk" onmouseover="show('reverse - реверс, задний ход, обратная сторона')" onmouseout="hide()">reverse()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

Toggles the direction of the animation or sets it to a specific direction:

<pre>// javascript
// will run from 100,100 to rects initial position
rect.animate(3000).move(100, 100).reverse()<br>
// sets direction to backwards
rect.animate(3000).move(100, 100).reverse(true)<br>
// sets direction to forwards (same as not calling reverse ever)
rect.animate(3000).move(100, 100).reverse(false)</pre><br>

<pre id="15stop"><span class="lnk" onmouseover="show('stop - стоп, остановка, прекращение')" onmouseout="hide()">stop()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

If you just want to stop an animation you can call the `stop()` method which has two optional arguments:
<div class=blockindent>
&nbsp; &#9679; &nbsp; jumpToEnd: Sets the values to the end of the animation<br>
&nbsp; &#9679; &nbsp; clearQueue: Remove all items from queue</div>

<pre>// javascript
rect.animate().move(200, 200)<br>
rect.stop()
// or e.g. (или, например,)
rect.stop(true)</pre>

Stopping an animation is irreversible.</div><br><br>


<h3 id="3">Расчет времени (тайминг)</h3>
<div class=blockindent><br>
<pre id="3at"><span class="lnk" onmouseover="show('at - предлог в')" onmouseout="hide()">at()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

Say you want to control the position of an animation with an external event, then the `at()` method will prove very useful:

<pre>// javascript
var animation = draw.rect(100, 100).move(50, 50).animate('=').move(200, 200)

document.onmousemove = function(event) {
  animation.at(event.clientX / 1000)
}</pre>

The value passed as the first argument of `at()` should be a number between `0` and `1`, `0` being the beginning of the animation and `1` being the end. Note that any values below `0` and above `1` will be normalized.

Also note that the value is eased after calling the function. Therefore the position specifies a position in time not in space.<br><br>

<pre id="3delay"><span class="lnk" onmouseover="show('delay - задержка, отсрочка')" onmouseout="hide()">delay()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

Alternatively, you can call `delay()` which will set a delay in ms before the next animation in the queue is run
<pre>// javascript
rect.animate({ ease: '&#60;', delay: '1.5s' }).attr({ fill: '#f03' }).delay(500).animate().dmove(50,50)</pre><br>

<pre id="3loop"><span class="lnk" onmouseover="show('loop - цикл, петля')" onmouseout="hide()">loop()</span></pre>
<div class=list>возвращает - <tt>SVG.FX</tt></div>

By default the `loop()` method creates and eternal loop:
<pre>// javascript
rect.animate(3000).move(100, 100).loop()</pre>

But the loop can also be a predefined number of times:
<pre>// javascript
rect.animate(3000).move(100, 100).loop(3)</pre>

Loops go from beginning to end and start over again (`0->1.0->1.0->1.`).

There is also a reverse flag that should be passed as the second argument:
<pre>// javascript
rect.animate(3000).move(100, 100).loop(3, true)</pre>

Loops will then be completely reversed before starting over (`0->1->0->1->0->1.`).<br><br>

<pre id="3once"><span class="lnk" onmouseover="show('once - один раз, однажды')" onmouseout="hide()">once()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

Finally, you can perform an action at a specific position only once. Just pass the position and the function which should be executed to the `once` method. You can also decide whether the position which is passed should be handled as position in time (not eased) or position in space (easing applied):

<pre>// javascript
// the 0.5 is handled as uneased value (you can omit the false)
rect.animate(3000).move(100, 100).once(0.5, function(pos, eased) {
  // do something
}, false)</pre>

<pre>// javascript
// the 0.5 is handled as eased value
rect.animate(3000).move(100, 100).once(0.5, function(pos, eased) {
  // do something
}, true)</pre>

The callback function gets the current position uneased and eased.<br><br>

<pre id="3queue"><span class="lnk" onmouseover="show('queue - очередь')" onmouseout="hide()">queue()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

If you want to call a custom funtion between two chained animations, you simply can queue them up:
<pre>// javascript
rect.animate({ ease: '&#60;', delay: '1.5s' }).attr({ fill: '#f03' }).queue(function(){<br>
    this.target().fill('#000')
    this.dequeue() // dont forget to call dequeue when the queue should continue running<br>
}).animate().dmove(50,50)</pre></div><br><br>


<h3 id="4">Функции обратного вызова</h3>
<div class=blockindent><br>

<pre id="4after"><span class="lnk" onmouseover="show('after - после, after all - после всего')" onmouseout="hide()">after / afterAll()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

Furthermore, you can add callback methods using `after()/afterAll()`:

<pre>// javascript
rect.animate(3000).move(100, 100).after(function(situation) {
  this.animate().attr({ fill: '#f06' })
})<br>
// or (или)
rect.animate(3000).move(100, 100).afterAll(function() {
  this.animate().attr({ fill: '#f06' })
})</pre>

The function gets the situation which was finished as first parameter. This doesn't apply to afterAll where no parameter is passed
Note that the `after()/afterAll()` method will never be called if the animation is looping eternally.
You can call `after()/afterAll()` multiple times to add more functions which should be executed.<br><br>

<pre id="4during"><span class="lnk" onmouseover="show('during - во время, during all - во время всего')" onmouseout="hide()">during / duringAll()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

If you want to perform your own actions during one/all animation you can use the `during()/duringAll()` method:

<pre>// javascript
var position
  , from = 100
  , to   = 300<br>
rect.animate(3000).move(100, 100).during(function(pos, morph, eased, situation) {
  position = from + (to - from) * pos
})<br>
// or (или)
rect.animate(3000).move(100, 100).duringAll(function(pos, morph, eased, situation) {
  position = from + (to - from) * pos
})</pre>

Note that `pos` is `0` in the beginning of the animation and `1` at the end of the animation.<br>

To make things easier a morphing function is passed as the second argument. This function accepts a `from` and `to` value as the first and second argument and they can be a number, unit or hex color:

<pre>// javascript
var ellipse = draw.ellipse(100, 100).attr('cx', '20%').fill('#333')<br>
rect.animate(3000).move(100, 100).during(function(pos, morph, eased, situation) {
  // numeric values
  ellipse.size(morph(100, 200), morph(100, 50))<br>
  // unit strings
  ellipse.attr('cx', morph('20%', '80%'))<br>
  // hex color strings
  ellipse.fill(morph('#333', '#ff0066'))
})</pre>
The `eased` parameter contains the position after the easing function was applied.
The last parameter holds the current situation related to the current `during` call.
You can call `during()/duringAll()` multiple times to add more functions which should be executed.</div><br><br>


<br><br>
</body></html>
