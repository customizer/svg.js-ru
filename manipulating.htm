<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>svg.js Справочное руководство</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>

<body>
<h3>Управление</h3>
Здесь все, что нужно знать об управлении элементами с помощью их атрибутов, преобразования, стилей, классов и многого другого.<br><br>

<h4 id="1">Атрибуты</h4>
<div class=blockindent><br>
<pre id="1attr_set"><span class="lnk" onmouseover="show('attr - сокращ. англ. слова attribute - атрибут, признак, свойство')" onmouseout="hide()">attr()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да (только для чисел (number), массивов (array), цвета (color), ... )</div>
Установка одиночного атрибута:
<pre>// javascript
rect.attr('x', 50)</pre>
Установка нескольких атрибутов одновременно:
<pre>// javascript
rect.attr({
  fill: '#f06'
, 'fill-opacity': 0.5
, stroke: '#000'
, 'stroke-width': 10
})</pre>
Установка атрибута с пространством имен (namespace):
<pre>// javascript
rect.attr('x', 50, 'http://www.w3.org/2000/svg')</pre>
Явное удаление атрибута:
<pre>// javascript
rect.attr('fill', null)</pre><br>

<pre id="1attr_get"><span class="lnk" onmouseover="show('attr - сокращ. англ. слова attribute - атрибут, признак, свойство')" onmouseout="hide()">attr()</span>          <i class=low>как получатель (getter)</i></pre>
<div class=list>возвращает значение (value) (строку (string), число (number), ... )</div>
Можно получать и устанавливать атрибуты элементов напрямую с помощью <tt>attr()</tt>.<br>
Получение одиночного атрибута:
<pre>// javascript
var x = rect.attr('x')</pre>
Получение всех атрибутов как объекта:
<pre>// javascript
var attributes = rect.attr()</pre></div><br>

<h4 id="2">Позиционирование</h4>
В то время как позиционирование элемента путем непосредственного задания его атрибутов работает только в том случае, если эти атрибуты изначально используются данным типом элемента;
описанные ниже методы позиционирования намного удобнее, так как они работают для всех типов элементов.<br><br>
Например, следующий код работает поскольку каждый элемент позиционируется установкой его исходных (собственных) атрибутов:
<pre>// javascript
rect.attr({ x: 20, y: 60 })
circle.attr({ cx: 50, cy: 40 })</pre>
Прямоугольник <tt>rect</tt> будет перемещен в соответствии с расположением его верхнего левого угла (т.е. нулевой точкой его координат) в новые координаты,
а круг <tt>circle</tt> будет перемещен в соответствии с его центром (локальные нулевые координаты круга находятся в центре).
Однако попытка переместить <tt>circle</tt> по его «верхнему левому углу» или<tt>rect</tt> по его центру потерпит неудачу.
Строки кода, показанные ниже, будут молчаливо игнорироваться, так как атрибуты, которым они адресованы, изначально не используются элементом, устанавливающим их:
However, trying to move a `circle` by its 'corner' or a `rect` by its centre in this way will fail. The following lines will get silently ignored as the attributes that are addressed are not natively used by the element setting them:

<pre>// javascript
rect.attr({ cx: 20, cy: 60 })
circle.attr({ x: 50, y: 40 })</pre>
Тем не менее, показанные ниже методы позиционирования, будут работать для всех типов элементов, независимо от того, являются ли атрибуты, которым они адресованы, исходными (родными) для данного типа.
Так что, в отличие от строк выше, эти строки работают просто отлично:
However, the positioning methods detailed below will work for all element types, regardless of whether the attributes being addressed are native to the type. So, unlike the lines above, these lines work just fine:

<pre>// javascript
rect.cx(20).cy(60)
circle.x(50).y(40)</pre>
Важно отметить все же, что эти методы предназначены только для использования с пользовательскими (безразмерными) координатами.
Если например, размер элемента задан в процентах или других единицах, методы позиционирования, которые обращаются к его собственным атрибутам, скорее всего, все еще будут работать, но те, которые обращаются к не родным атрибутам, дадут неожиданные результаты - как получатели (геттеры), так и установщики (сеттеры)!
It is important to note, though, that these methods are only intended for use with user (unitless) coordinates. If for example, an element has its size set via percentages or other units, the positioning methods that address its native attributes will most likely still work, but the ones that address non-native attributes will give unexpected results -- as both getters and setters!
<div class=blockindent><br>
<pre id="2move"><span class="lnk" onmouseover="show('move - перемещать, двигать')" onmouseout="hide()">move()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его верхнему левому углу в позицию, задаваемую координатами <tt>x</tt> и <tt>y</tt>.
<pre>// javascript
rect.move(200, 350)</pre><br>

<pre id="2x_set"><span class="lnk" onmouseover="show('координата x')" onmouseout="hide()">x()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его верхнему левому углу только по оси <tt>x</tt>:
<pre>// javascript
rect.x(200)</pre><br>

<pre id="2x_get"><span class="lnk" onmouseover="show('координата x')" onmouseout="hide()">x()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>x()</tt> без аргумента работает как получатель (геттер):
<pre>// javascript
var x = rect.x()</pre><br>

<pre id="2y_set"><span class="lnk" onmouseover="show('координата y')" onmouseout="hide()">y()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его верхнему левому углу только по оси <tt>y</tt>:
<pre>// javascript
rect.y(350)</pre><br>

<pre id="2y_get"><span class="lnk" onmouseover="show('координата y')" onmouseout="hide()">y()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>y()</tt> без аргумента работает как получатель (геттер):
<pre>// javascript
var y = rect.y()</pre><br>

<pre id="2center"><span class="lnk" onmouseover="show('center - центр')" onmouseout="hide()">center()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его центру в позицию, задаваемую координатами <tt>cx</tt> и <tt>cy</tt>.
<pre>// javascript
rect.center(150, 150)</pre><br>

<pre id="2cx_set"><span class="lnk" onmouseover="show('cx - сокращ. англ. слов center x - координата x центра')" onmouseout="hide()">cx()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его центру только по оси <tt>x</tt>:
<pre>// javascript
rect.cx(200)</pre><br>

<pre id="2cx_get"><span class="lnk" onmouseover="show('cx - сокращ. англ. слов center x - координата x центра')" onmouseout="hide()">cx()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>cx()</tt> без аргумента работает как получатель (геттер):
<pre>// javascript
var cx = rect.cx()</pre><br>

<pre id="2cy_set"><span class="lnk" onmouseover="show('cy - сокращ. англ. слов center y - координата y центра')" onmouseout="hide()">cy()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его центру только по оси <tt>y</tt>:
<pre>// javascript
rect.cy(350)</pre><br>

<pre id="2cy_get"><span class="lnk" onmouseover="show('cy - сокращ. англ. слов center y - координата y центра')" onmouseout="hide()">cy()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>cy()</tt> без аргумента работает как получатель (геттер):
<pre>// javascript
var cy = rect.cy()</pre><br>

<pre id="2dmove"><span class="lnk" onmouseover="show('dmove - сокращ. англ. слов d move - перемещение')" onmouseout="hide()">dmove()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Сдвигает элемент по осям координат относительно его текущего положения на заданные значения <tt>x</tt> и <tt>y</tt>.
Shift the element in both the `x` and `y` directions relative to its current position:

<pre>// javascript
rect.dmove(10, 30)</pre>
<div class=note><b>Примечание:</b>**Note**: when using `dmove()` (and `dx()` or `dy()` too for that matter), always make sure you provide values of the same unit the element is originally positioned in. So if the element is at `x:10%`, use `element.dx('5%')` and not `element.dx('5px')`.</div><br>

<pre id="2dx"><span class="lnk" onmouseover="show('dx - сокращ. англ. слов d x - ')" onmouseout="hide()">dx()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Сдвигает элемент по оси <tt>x</tt> относительно его текущего положения:
<pre>// javascript
rect.dx(200)</pre><br>

<pre id="2dy"><span class="lnk" onmouseover="show('dy - сокращ. англ. слов d y - ')" onmouseout="hide()">dy()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Сдвигает элемент по оси <tt>y</tt> относительно его текущего положения:
<pre>// javascript
rect.dy(200)</pre></div><br>


<h4 id="3">Изменение размеров (ресайзинг)</h4>
<div class=blockindent><br>
<pre id="3size"><span class="lnk" onmouseover="show('size - размер')" onmouseout="hide()">size()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Установка размера элемента по заданным ширине (<tt>width</tt>) и высоте (<tt>height</tt>).
<pre>// javascript
rect.size(200, 300)</pre>
Также возможно пропорциональное изменение размеров без передачи значения аргумента <tt>height</tt>.
<pre>// javascript
rect.size(200)</pre>
Или передачей <tt>null</tt> в качестве значения для аргумента <tt>width</tt>:
<pre>// javascript
rect.size(null, 200)</pre>

As with positioning, the size of an element could be set by using `attr()`. But because every type of element is handles its size differently the `size()` method is much more convenient.<br>

There is one exception though: for `SVG.Text` elements, this method takes only one argument and applies the given value to the `font-size` attribute.<br><br>

<pre id="3width_set"><span class="lnk" onmouseover="show('width - ширина')" onmouseout="hide()">width()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Установка ширины элемента:
<pre>// javascript
rect.width(200)</pre><br>

<pre id="3width_get"><span class="lnk" onmouseover="show('width - ширина')" onmouseout="hide()">width()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
<pre>// javascript
var width = rect.width()</pre><br>

<pre id="3height_set"><span class="lnk" onmouseover="show('height - высота')" onmouseout="hide()">height()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Установка высоты элемента:
<pre>// javascript
rect.height(325)</pre><br>

<pre id="3height_get"><span class="lnk" onmouseover="show('height - высота')" onmouseout="hide()">height()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
<pre>// javascript
rect.height()</pre><br>

<pre id="3radius"><span class="lnk" onmouseover="show('radius - радиус')" onmouseout="hide()">radius()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>radius()</tt> могут использовать окружности, эллипсы и прямоугольники. В прямоугольниках этот аргумент определяет закругление углов.<br>
Для окружности аргумент устанавливает атрибут <tt>r</tt> - радиус.
<pre>// javascript
circle.radius(10)</pre>
Для эллипсов и прямоугольников передается два аргумента по установке отдельных атрибутов <tt>rx</tt> и <tt>ry</tt>. Или передается один аргумент, означающий что оба атрибута равны между собой.
<pre>// javascript
ellipse.radius(10, 20)
rect.radius(5)</pre></div><br><br>


<h4 id="4">Синтаксический "сахар"</h4>
<div class=note_trans><b>Примечание переводчика:</b> <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80" target="_blank">Синтаксический сахар</a> (англ. syntactic sugar) в языке программирования
— это синтаксические возможности, применение которых не влияет на поведение программы, но делает использование языка более удобным для человека.<br>
Это может быть любой элемент синтаксиса, который даёт программисту альтернативный способ записи уже имеющейся в языке синтаксической конструкции,
и при этом является более удобным, или более кратким, или похожим на другой распространённый способ записи, или помогает писать программы в хорошем стиле.</div>
<div class=blockindent><br>
<pre id="4fill"><span class="lnk" onmouseover="show('fill - заполнение, заливка')" onmouseout="hide()">fill()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Метод <tt>fill()</tt> является хорошей альтернативой методу <tt>attr()</tt>:
<pre>// javascript
rect.fill({ color: '#f06', opacity: 0.6 })</pre>
Также будет работать и одно шестнадцатиричное строковое значение:
A single hex string will work as well:
<pre>// javascript
rect.fill('#f06')</pre>
И последнее, но не менее важное; в качестве заливки также можно использовать картинку, просто передав URL-адрес изображения:
<pre>// javascript
rect.fill('images/shade.jpg')</pre>
Или, если нужно управлять размером изображения, можно передать картинку вот так:
<pre>// javascript
rect.fill(draw.image('images/shade.jpg', 20, 20))</pre><br>

<pre id="4stroke"><span class="lnk" onmouseover="show('stroke - штриховать')" onmouseout="hide()">stroke()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Метод <tt>stroke()</tt> аналогичен методу <tt>fill()</tt>:
<pre>// javascript
rect.stroke({ color: '#f06', opacity: 0.6, width: 5 })</pre>
Как и у метода <tt>fill()</tt>, здесь будет работать одиночное шестнадцатиричное строковое значение:
<pre>// javascript
rect.stroke('#f06')</pre>
Также нет отличий от метода <tt>fill()</tt> и в использовании картинки при штриховке, простая передача URL-адреса изображения:
<pre>// javascript
rect.stroke('images/shade.jpg')</pre>
Или, если нужно управлять размером изображения, можно передать картинку вот так:
<pre>// javascript
rect.stroke(draw.image('images/shade.jpg', 20, 20))</pre><br>

<pre id="4opacity"><span class="lnk" onmouseover="show('opacity - непрозрачность')" onmouseout="hide()">opacity()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Метод для установки общей непрозрачности элемента:
<pre>// javascript
rect.opacity(0.5)</pre>
</div><br><br>


<h4 id="5">Трансформация</h4>
<div class=blockindent><br>
<pre id="5transform_set"><span class="lnk" onmouseover="show('transform - преобразование')" onmouseout="hide()">transform()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>

As a setter it has two ways of working. By default transformations are absolute. For example, if you call:

<pre>// javascript
element.transform({ rotation: 125 }).transform({ rotation: 37.5 })</pre>

The resulting rotation will be `37.5` and not the sum of the two transformations. But if that's what you want there is a way out by adding the `relative` parameter. That would be:
<pre>// javascript
element.transform({ rotation: 125 }).transform({ rotation: 37.5, relative: true })</pre>

Alternatively a relative flag can be passed as the second argument:
<pre>// javascript
element.transform({ rotation: 125 }).transform({ rotation: 37.5 }, true)</pre>

Доступные преобразования:<br>
&nbsp; &#9679; &nbsp; <tt>rotation</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>scale</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>scaleX</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>scaleY</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>skewX</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>skewY</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>x</tt><br>
&nbsp; &#9679; &nbsp; <tt>y</tt><br>
&nbsp; &#9679; &nbsp; <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, <tt>d</tt>, <tt>e</tt> и/или <tt>f</tt> или существующая матрица вместо объекта.<br><br>

<pre id="5transform_get"><span class="lnk" onmouseover="show('transform - преобразование')" onmouseout="hide()">transform()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>transform()</tt> без аргументов действует как полноценный получатель (геттер).
<pre>// javascript
element.transform()</pre>
Возвращаемый <tt>object</tt> содержит следующие значения:<br>
&nbsp; &#9679; &nbsp; <tt>x</tt> (перемещение по оси <tt>x</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>y</tt> (перемещение по оси <tt>y</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>skewX</tt> (calculated skew on x-axis)<br>
&nbsp; &#9679; &nbsp; <tt>skewY</tt> (calculated skew on y-axis)<br>
&nbsp; &#9679; &nbsp; <tt>scaleX</tt> (рассчитанный масштаб по оси <tt>x</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>scaleY</tt> (рассчитанный масштаб по оси <tt>y</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>rotation</tt> (рассчитанный поворот)<br>
&nbsp; &#9679; &nbsp; <tt>cx</tt> (last used rotation centre on x-axis)<br>
&nbsp; &#9679; &nbsp; <tt>cy</tt> (last used rotation centre on y-axis)<br>
Кроме того, для нужного свойства можно передать строковое значение:<br>
<pre>// javascript
element.transform('rotation')</pre><br>

<pre id="5flip"><span class="lnk" onmouseover="show('flip - переворот')" onmouseout="hide()">flip()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Переворачивает элемент вокруг заданной оси:
<pre>// javascript
element.flip('x')</pre>
или
<pre>// javascript
element.flip('y')</pre>
По умолчанию, элементы переворачиваются вокруг своей центральной точки. Позицию осевого переворота можно определять вторым аргументом:
<pre>// javascript
element.flip('x', 150)</pre>
или
<pre>// javascript
element.flip('y', 100)</pre>
Наконец, также можно переворачивать элемент сразу вокруг обоих осей не указывая значения оси.
<pre>// javascript
element.flip()</pre>

And flipping on both axes at the same offset can be done by passing only a numeric value:
<pre>// javascript
element.flip(5)</pre><br>

<pre id="5rotate"><span class="lnk" onmouseover="show('rotate - поворот')" onmouseout="hide()">rotate()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>rotate()</tt> автоматически поворачивает элементы в соответствии с центральной точкой элемента:
<pre>// javascript
// rotate(degrees)
element.rotate(45)</pre>
Хотя также можно определить и конкретную точку поворота:
<pre>// javascript
// rotate(degrees, cx, cy)
element.rotate(45, 50, 50)</pre><br>

<pre id="5skew"><span class="lnk" onmouseover="show('skew - ')" onmouseout="hide()">skew()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>skew()</tt> принимает значения <tt>x</tt> и <tt>y</tt>.
<pre>// javascript
// skew(x, y)
element.skew(0, 45)</pre><br>

<pre id="5scale"><span class="lnk" onmouseover="show('scale - масштаб')" onmouseout="hide()">scale()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>scale()</tt> принимает значения <tt>x</tt> и <tt>y</tt>.
<pre>// javascript
// scale(x, y)
element.scale(0.5, -1)</pre><br>

<pre id="5translate"><span class="lnk" onmouseover="show('translate - перевод, перенос')" onmouseout="hide()">translate()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>translate()</tt> принимает значения <tt>x</tt> и <tt>y</tt>.
<pre>// javascript
// translate(x, y)
element.translate(0.5, -1)</pre></div><br><br>


<h4 id="6">Стили</h4>
<div class=blockindent><br>
<pre id="6style_set"><span class="lnk" onmouseover="show('style - стиль')" onmouseout="hide()">style()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
С помощью метода <tt>style()</tt> можно управлять атрибутом <tt>style</tt> также как атрибутами с помощью <tt>attr</tt>:
<pre>// javascript
element.style('cursor', 'pointer')</pre>
Несколько стилей могут быть установлены одновременно, если в качестве аргумента использовать объект:
<pre>// javascript
element.style({ cursor: 'pointer', fill: '#f03' })</pre>
Или css-строку:
<pre>// javascript
element.style('cursor:pointer;fill:#f03;')</pre>
Прямое удаление отдельных стилевых определений работает точно также как у метода <tt>attr()</tt>:
<pre>// javascript
element.style('cursor', null)</pre><br>

<pre id="6style_get"><span class="lnk" onmouseover="show('style - стиль')" onmouseout="hide()">transform()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value) (строку (string), число (number), ...)</div>
Аналогично методу <tt>attr()</tt>, метод <tt>style()</tt> также может действовать как получатель (геттер):
<pre>// javascript
element.style('cursor')
// => pointer (указатель)</pre>
Или даже как полный получатель:
<pre>// javascript
element.style()
// => 'cursor:pointer;fill:#f03;'</pre><br>

<pre id="6hide"><span class="lnk" onmouseover="show('hide - скрыть, спрятать')" onmouseout="hide()">hide()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Скрыть элемент:
<pre>// javascript
element.hide()</pre><br>

<pre id="6show"><span class="lnk" onmouseover="show('show - показать, вывести, предъявить')" onmouseout="hide()">show()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Показать (отобразить) элемент:
<pre>// javascript
element.show()</pre><br>

<pre id="6visible"><span class="lnk" onmouseover="show('visible - видимый, отображаемый')" onmouseout="hide()">visible()</span></pre>
<div class=list>возвращает - логическое значение (boolean)</div>
Метод для проверки, является ли элемент видимым:
<pre>// javascript
element.visible()</pre></div><br>


<h4 id="7">Классы</h4>
<div class=blockindent><br>
<pre id="7addClass"><span class="lnk" onmouseover="show('add class - добавить класс')" onmouseout="hide()">addClass()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Добавляет заданный класс CSS:
<pre>// javascript
element.addClass('pink-flower')</pre><br>

<pre id="7classes"><span class="lnk" onmouseover="show('classes - классы')" onmouseout="hide()">classes()</span></pre>
<div class=list>возвращает - массив (array)</div>
Получает классы CSS для узла в виде массива:
<pre>// javascript
element.classes()</pre><br>

<pre id="7hasClass"><span class="lnk" onmouseover="show('has class - имеет класс')" onmouseout="hide()">hasClass()</span></pre>
<div class=list>возвращает - логическое значение (boolean)</div>
Проверяет наличие заданного класса CSS:
<pre>// javascript
element.hasClass('purple-rain')</pre><br>

<pre id="7removeClass"><span class="lnk" onmouseover="show('remove class - удалить класс')" onmouseout="hide()">removeClass()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Удаляет заданный класс CSS:
<pre>// javascript
element.removeClass('pink-flower')</pre><br>

<pre id="7toggleClass"><span class="lnk" onmouseover="show('toggle class - переключает класс')" onmouseout="hide()">toggleClass()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Переключает заданный класс CSS:
<pre>// javascript
element.toggleClass('pink-flower')</pre></div><br><br>


<h4 id="8">Данные</h4>
Метод <tt>data()</tt> позволяет связывать произвольные объекты, строки и числа с элементами SVG.
The `data()` method allows you to bind arbitrary objects, strings and numbers to SVG elements.
<div class=blockindent><br>
<pre id="8data_get"><span class="lnk" onmouseover="show('data - данные')" onmouseout="hide()">data()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (<tt>value</tt>)</div>
Получает значения аналогично методу <tt>attr()</tt>:
<pre>// javascript
var key = rect.data('key')</pre><br>

<pre id="8data_set"><span class="lnk" onmouseover="show('data - данные')" onmouseout="hide()">data()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>

<pre>// javascript
rect.data('key', { value: { data: 0.3 }})</pre>
Или устанавливает сразу несколько значений:
<pre>// javascript
rect.data({
  forbidden: 'fruit'
, multiple: {
    values: 'in'
  , an: 'object'
  }
})</pre>
Полное удаление данных:
<pre>// javascript
rect.data('key', null)</pre>
Значения всегда будут храниться в формате JSON и в некоторых случаях это может быть нежелательно. Если нужно сохранить значение как есть, просто передайте <tt>true</tt> в качестве третьего аргумента:
<pre>// javascript
rect.data('key', 'value', true)</pre></div><br><br>


<h4 id="9">Память</h4>
<div class=blockindent><br>
<pre id="9remember_get"><span class="lnk" onmouseover="show('remember - вспомнить')" onmouseout="hide()">remember()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (<tt>value</tt>)</div>
Для восстановления памяти
<pre>// javascript
rect.remember('oldBBox')</pre><br>

<pre id="9remember_set"><span class="lnk" onmouseover="show('remember - запомнить')" onmouseout="hide()">remember()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
Сохранение данных в памяти очень похоже на установку атрибутов:
<pre>// javascript
rect.remember('oldBBox', rect.bbox())</pre>
Также можно запоминать несколько значений сразу:
<pre>// javascript
rect.remember({
  oldFill:    rect.attr('fill')
, oldStroke:  rect.attr('stroke')
})</pre><br>

<pre id="9forget"><span class="lnk" onmouseover="show('forget - забыть')" onmouseout="hide()">forget()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Стирание одного значения в памяти:
<pre>// javascript
rect.forget('oldBBox')</pre>
Или стирание сразу нескольких значений в памяти:
<pre>// javascript
rect.forget('oldFill', 'oldStroke')</pre>
И наконец, просто стереть всю память целиком:
<pre>// javascript
rect.forget()</pre></div><br><br>


<h4 id="10">"Дерево" документа</h4>
<div class=blockindent><br>
<pre id="10add"><span class="lnk" onmouseover="show('add - добавить')" onmouseout="hide()">add()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Устанавливает вызывающий элемент (в примере это <tt>group</tt>) в качестве родительского узла для аргумента (т.е. <tt>rect</tt>). Возвращает родительский элемент:
<pre>// javascript
var rect = draw.rect(100, 100)
var group = draw.group()<br>
group.add(rect) //-> returns group (возвращает группу)</pre><br>

<pre id="10addTo"><span class="lnk" onmouseover="show('add to - добавить в ...')" onmouseout="hide()">addTo()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Устанавливает вызывающий элемент как дочерний узел аргумента. Возвращает дочерний элемент:
<pre>// javascript
rect.addTo(group) //-> returns rect (возвращает элемент rect)</pre><br>

<pre id="10clone"><span class="lnk" onmouseover="show('clone - клон, штамп')" onmouseout="hide()">clone()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Метод <tt>clone()</tt> удобно использовать для получения точной копии элемента:
<pre>// javascript
var clone = rect.clone()</pre>
Данный метод создает новую, несвязанную копию. Чтобы сделать связанную копию, смотрите элемент <tt><a href="elements.htm#17" onmouseover="show('Элементы / SVG.Use')" onmouseout="hide()">use</a></tt>.<br>
По умолчанию клонированный элемент размещается непосредственно после исходного элемента.
При передаче методу <tt>clone()</tt> параметра с родительским элементом, он добавит клонированный элемент к заданному родительскому элементу.<br><br>

<pre id="10put"><span class="lnk" onmouseover="show('put - положить')" onmouseout="hide()">put()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Устанавливает вызывающий элемент (в примере это <tt>group</tt>) в качестве родительского узла для аргумента (т.е. <tt>rect</tt>). Возвращает дочерний элемент:
<pre>// javascript
group.put(rect) //-> returns rect (возвращает элемент rect)</pre><br>

<pre id="10putIn"><span class="lnk" onmouseover="show('put in - положить в ...')" onmouseout="hide()">putIn()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Устанавливает вызывающий элемент (в примере это <tt>rect</tt>) в качестве дочернего узла для аргумента (т.е. для <tt>group</tt>). Возвращает родительский элемент:
<pre>// javascript
rect.putIn(group) //-> returns group (возвращает группу)</pre><br>

<pre id="10remove"><span class="lnk" onmouseover="show('remove - удалить')" onmouseout="hide()">remove()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Удаляет вызывающий элемент из svg-документа:
<pre>// javascript
rect.remove()</pre><br>

<pre id="10replace"><span class="lnk" onmouseover="show('replace - заменять, замещать')" onmouseout="hide()">replace()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
В позиции вызывающего элемента в svg-документе, вызывающий элемент (в примере это <tt>rect</tt>) заменяется элементом, переданным методу (в примере это <tt>circle</tt>).
<pre>// javascript
rect.replace(draw.circle(100))</pre><br>

<pre id="10toDoc"><span class="lnk" onmouseover="show('to doc - в документ')" onmouseout="hide()">toDoc()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Тоже самое, что и <tt>toParent()</tt>, но с коренным узлом в качестве родительского.
Same as `toParent()` but with the root-node as parent<br><br>

<pre id="10toParent"><span class="lnk" onmouseover="show('to parent - ')" onmouseout="hide()">toParent()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>

Moves an element to a different parent (similar to `addTo`), but without changing its visual representation. All transformations are merged and applied to the element.

<pre>// javascript
rect.toParent(group) // looks the same as before</pre><br>

<pre id="10ungroup"><span class="lnk" onmouseover="show('ungroup - разгруппировать<br>flatten - выравнивать, расплющить')" onmouseout="hide()">ungroup() / flatten()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Разбивает группу/контейнер и перемещает все элементы в данный родительский узел, не изменяя их видимого представления. Результатом является плоская структура SVG, например, для экспорта.
Break up a group/container and move all the elements to a given parent node without changing their visual representations. The result is a flat svg structure, e.g. for exporting.<br><br>
Разгруппировать все элементы в этой группе рекурсивно и поместить их в данного родителя
Ungroup all elements in this group recursively and places them into the given parent

<pre>// javascript
group.ungroup(parent, depth)
// (default: parent container of the calling element)
// (default: parent container of the calling element)</pre>
Вызов этого метода на весь документ целиком для получения "плоской" svg-структуры:
Call it on the whole document to get a flat svg structure:

<pre>// javascript
drawing.ungroup()</pre>
Расформировываем группу (<tt>group</tt>) и помещаем все элементы в <tt>drawing</tt>.
Break up the group and places all elements in the drawing:

<pre>// javascript
group.ungroup(drawing)</pre>

Break up all groups until it reaches a depth of 3:

<pre>// javascript
drawing.ungroup(null, 3)</pre>

Flat and export svg:

<pre>// javascript
var svgString = drawing.ungroup().svg()</pre></div><br><br>


<h4 id="11">Организация элементов</h4>
Можно изменять расположение элементов в пределах их родительского SVG-документа при помощи следующих методов:
<div class=blockindent><br>
<pre id="11after"><span class="lnk" onmouseover="show('after - после, затем')" onmouseout="hide()">after()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Вставляет один элемент после другого:
<pre>// javascript
// inserts circle after rect (вставка круга после прямоугольника)
rect.after(circle)</pre><br>

<pre id="11before"><span class="lnk" onmouseover="show('before - перед, до, раньше')" onmouseout="hide()">before()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Вставляет один элемент перед другим:
<pre>// javascript
// inserts circle before rect (вставка круга перед прямоугольником)
rect.before(circle)</pre><br>

<pre id="11back"><span class="lnk" onmouseover="show('back - назад, обратно')" onmouseout="hide()">back()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Перемещает элемент в конец:
Move element to the back:

<pre>// javascript
rect.back()</pre><br>

<pre id="11backward"><span class="lnk" onmouseover="show('backward - назад, в обратном направлении')" onmouseout="hide()">backward()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Перемещает элемент на один шаг назад:
<pre>// javascript
rect.backward()</pre><br>

<pre id="11front"><span class="lnk" onmouseover="show('front - перед, передняя часть')" onmouseout="hide()">front()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Перемещает элемент в начало:
Move element to the front:

<pre>// javascript
rect.front()</pre><br>

<pre id="11forward"><span class="lnk" onmouseover="show('forward - вперед')" onmouseout="hide()">forward()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Перемещает элемент на один шаг вперед:
<pre>// javascript
rect.forward()</pre><br>

<pre id="11next"><span class="lnk" onmouseover="show('next - следующий')" onmouseout="hide()">next()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Получает следующий, одноуровневый элемент (соседний):
<pre>// javascript
rect.next()</pre><br>

<pre id="11position"><span class="lnk" onmouseover="show('position - позиция, положение')" onmouseout="hide()">position()</span></pre>
<div class=list>возвращает  число (<tt>number</tt>)</div>
Получает позицию (в виде числа) прямоугольника (<tt>rect</tt>) среди своих соседей по уровню иерархии:
<pre>// javascript
rect.position()</pre><br>

<pre id="11previous"><span class="lnk" onmouseover="show('previous - предыдущий')" onmouseout="hide()">previous()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Получает предыдущий, одноуровневый элемент (соседний):
<pre>// javascript
rect.previous()</pre><br>

<pre id="11siblings"><span class="lnk" onmouseover="show('siblings - одноуровневые элементы, братья и сестры, сибсы')" onmouseout="hide()">siblings()</span></pre>
<div class=list>возвращает - массив (<tt>array</tt>)</div>
Метод используется для получения всех соседних элементов, включая и сам прямоугольник <tt>rect</tt>. То есть, получаем все элементы на одном уровне с вызывающим, включая и сам вызывающий элемент.<br>
Плагин (модуль) <tt>arrange.js</tt> предоставляет несколько дополнительных методов.
<pre>// javascript
rect.siblings()</pre></div><br><br>


<h4 id="12">Геометрия</h4>
<div class=blockindent><br>
<pre id="12point"><span class="lnk" onmouseover="show('point - точка')" onmouseout="hide()">point()</span></pre>
<div class=list>возвращает - <tt><a href="classes.htm#8" onmouseover="show('SVG.Point')" onmouseout="hide()">SVG.Point</a></tt></div>
Преобразует координаты точки из системы коодинат экрана в систему координат элементов.
<pre>// javascript
// e is some mouseevent (e - это какое-либо "мышиное" событие)
var point = path.point(e.screenX, e.screenY) // {x, y}</pre><br>

<pre id="12inside"><span class="lnk" onmouseover="show('inside - внутри')" onmouseout="hide()">inside()</span></pre>
<div class=list>возвращает - логическое значение (boolean)</div>
Метод <tt>inside()</tt> используется для проверки, находится ли заданная точка внутри ограничительной рамки элемента:
<pre>// javascript
var rect = draw.rect(100, 100).move(50, 50)<br>
rect.inside(25, 30) //-> returns false (возвращает значение false - ложь)
rect.inside(60, 70) //-> returns true (возвращает значение true - истина)</pre>
<div class=note><b>Примечание:</b> позиция по координатам <tt>x</tt> и <tt>y</tt> проверяется относительно позиции элемента. Никакое смещение родительского элемента не учитывается.</div></div><br>

<br><br>
</body></html>
