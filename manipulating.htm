<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>svg.js Справочное руководство</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>

<body>
<h3>Управление</h3>
Здесь все, что нужно знать об управлении элементами с помощью их атрибутов, преобразования, стилей, классов и многого другого.<br><br>

<h4 id="1">Атрибуты</h4>
<div class=blockindent><br>
<pre id="1attr_set"><span class="lnk" onmouseover="show('attr - сокращ. англ. слова attribute - атрибут, признак, свойство')" onmouseout="hide()">attr()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да (только для чисел (number), массивов (array), цвета (color), ... )</div>
Установка одиночного атрибута:
<pre>// javascript
rect.attr('x', 50)</pre>
Установка нескольких атрибутов одновременно:
<pre>// javascript
rect.attr({
  fill: '#f06'
, 'fill-opacity': 0.5
, stroke: '#000'
, 'stroke-width': 10
})</pre>
Установка атрибута с пространством имен (namespace):
<pre>// javascript
rect.attr('x', 50, 'http://www.w3.org/2000/svg')</pre>
Явное удаление атрибута:
<pre>// javascript
rect.attr('fill', null)</pre><br>

<pre id="1attr_get"><span class="lnk" onmouseover="show('attr - сокращ. англ. слова attribute - атрибут, признак, свойство')" onmouseout="hide()">attr()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value) (строку (string), число (number), ... )</div>
Можно получать и устанавливать атрибуты элементов напрямую с помощью <tt>attr()</tt>.<br>
Получение одиночного атрибута:
<pre>// javascript
var x = rect.attr('x')</pre>
Получение всех атрибутов как объекта:
<pre>// javascript
var attributes = rect.attr()</pre></div><br>

<h4 id="2">Позиционирование</h4>
В то время как позиционирование элемента путем непосредственного задания его атрибутов работает только в том случае, если эти атрибуты изначально используются данным типом элемента;
описанные ниже методы позиционирования намного удобнее, так как они работают для всех типов элементов.<br><br>
Например, следующий код работает поскольку каждый элемент позиционируется установкой его исходных (собственных) атрибутов:
<pre>// javascript
rect.attr({ x: 20, y: 60 })
circle.attr({ cx: 50, cy: 40 })</pre>
Прямоугольник <tt>rect</tt> будет перемещен в соответствии с расположением его верхнего левого угла (т.е. нулевой точкой его координат) в новые координаты,
а круг <tt>circle</tt> будет перемещен в соответствии с его центром (локальные нулевые координаты круга находятся в центре).
Однако попытка переместить <tt>circle</tt> по его «верхнему левому углу» или <tt>rect</tt> по его центру потерпит неудачу.
Строки кода, показанные ниже, будут молчаливо игнорироваться, так как атрибуты, которым они адресованы, изначально не используются элементом, устанавливающим их:
<pre>// javascript
rect.attr({ cx: 20, cy: 60 })
circle.attr({ x: 50, y: 40 })</pre>
Тем не менее, показанные ниже методы позиционирования, будут работать для всех типов элементов, независимо от того, являются ли атрибуты, которым они адресованы, исходными (родными) для данного типа.
Так что, в отличие от строк выше, эти строки работают просто отлично:
<pre>// javascript
rect.cx(20).cy(60)
circle.x(50).y(40)</pre>
Важно отметить все же, что эти методы предназначены только для использования с пользовательскими (безразмерными) координатами.
Если например, размер элемента задан в процентах или других единицах, методы позиционирования, которые обращаются к его собственным атрибутам, скорее всего, все еще будут работать,
но те, которые обращаются к неродным атрибутам, дадут неожиданные результаты - как получатели (геттеры), так и установщики (сеттеры)!
<div class=blockindent><br>
<pre id="2move"><span class="lnk" onmouseover="show('move - перемещать, двигать')" onmouseout="hide()">move()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его верхнему левому углу в позицию, задаваемую координатами <tt>x</tt> и <tt>y</tt>.
<pre>// javascript
rect.move(200, 350)</pre><br>

<pre id="2x_set"><span class="lnk" onmouseover="show('координата x')" onmouseout="hide()">x()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его верхнему левому углу только по оси <tt>x</tt>:
<pre>// javascript
rect.x(200)</pre><br>

<pre id="2x_get"><span class="lnk" onmouseover="show('координата x')" onmouseout="hide()">x()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>x()</tt> без аргумента работает как получатель (геттер):
<pre>// javascript
var x = rect.x()</pre><br>

<pre id="2y_set"><span class="lnk" onmouseover="show('координата y')" onmouseout="hide()">y()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его верхнему левому углу только по оси <tt>y</tt>:
<pre>// javascript
rect.y(350)</pre><br>

<pre id="2y_get"><span class="lnk" onmouseover="show('координата y')" onmouseout="hide()">y()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>y()</tt> без аргумента работает как получатель (геттер):
<pre>// javascript
var y = rect.y()</pre><br>

<pre id="2center"><span class="lnk" onmouseover="show('center - центр')" onmouseout="hide()">center()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его центру в позицию, задаваемую координатами <tt>cx</tt> и <tt>cy</tt>.
<pre>// javascript
rect.center(150, 150)</pre><br>

<pre id="2cx_set"><span class="lnk" onmouseover="show('cx - сокращ. англ. слов center x - координата x центра')" onmouseout="hide()">cx()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его центру только по оси <tt>x</tt>:
<pre>// javascript
rect.cx(200)</pre><br>

<pre id="2cx_get"><span class="lnk" onmouseover="show('cx - сокращ. англ. слов center x - координата x центра')" onmouseout="hide()">cx()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>cx()</tt> без аргумента работает как получатель (геттер):
<pre>// javascript
var cx = rect.cx()</pre><br>

<pre id="2cy_set"><span class="lnk" onmouseover="show('cy - сокращ. англ. слов center y - координата y центра')" onmouseout="hide()">cy()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Перемещает элемент по его центру только по оси <tt>y</tt>:
<pre>// javascript
rect.cy(350)</pre><br>

<pre id="2cy_get"><span class="lnk" onmouseover="show('cy - сокращ. англ. слов center y - координата y центра')" onmouseout="hide()">cy()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>cy()</tt> без аргумента работает как получатель (геттер):
<pre>// javascript
var cy = rect.cy()</pre><br>

<pre id="2dmove"><span class="lnk" onmouseover="show('dmove - сокращ. англ. слов d move - перемещение')" onmouseout="hide()">dmove()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Сдвигает элемент по осям координат, относительно его текущего положения, на заданные значения <tt>x</tt> и <tt>y</tt>.
<pre>// javascript
rect.dmove(10, 30)</pre>
<div class=note><b>Примечание:</b> при использовании <tt>dmove()</tt> (а также <tt>dx()</tt> или <tt>dy()</tt>), всегда предоставляйте значения одного и того же элемента в тех же единицах, которые были представлены для него изначально.
Так, если элемент был представлен как <tt>x:10%</tt>, то используйте <tt>element.dx('5%')</tt>, а не <tt>element.dx('5px')</tt>.</div><br>

<pre id="2dx"><span class="lnk" onmouseover="show('dx - сокращ. англ. слов d x - ')" onmouseout="hide()">dx()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Сдвигает элемент по оси <tt>x</tt> относительно его текущего положения:
<pre>// javascript
rect.dx(200)</pre><br>

<pre id="2dy"><span class="lnk" onmouseover="show('dy - сокращ. англ. слов d y - ')" onmouseout="hide()">dy()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Сдвигает элемент по оси <tt>y</tt> относительно его текущего положения:
<pre>// javascript
rect.dy(200)</pre></div><br>


<h4 id="3">Изменение размеров (ресайзинг)</h4>
<div class=blockindent><br>
<pre id="3size"><span class="lnk" onmouseover="show('size - размер')" onmouseout="hide()">size()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Установка размера элемента по заданным ширине (<tt>width</tt>) и высоте (<tt>height</tt>).
<pre>// javascript
rect.size(200, 300)</pre>
Также возможно пропорциональное изменение размеров без передачи значения аргумента <tt>height</tt>.
<pre>// javascript
rect.size(200)</pre>
Или передачей <tt>null</tt> в качестве значения для аргумента <tt>width</tt>:
<pre>// javascript
rect.size(null, 200)</pre>
Как и в случае с позиционированием, размер элемента может быть установлен с помощью <tt>attr()</tt>. Но, поскольку каждый тип элемента обрабатывает свой размер по-разному, метод <tt>size()</tt> гораздо удобнее.<br>
Однако есть одно исключение: для элементов <tt>SVG.Text</tt> данный метод принимает только один аргумент и применяет заданное значение к атрибуту <tt>font-size</tt>.<br><br>

<pre id="3width_set"><span class="lnk" onmouseover="show('width - ширина')" onmouseout="hide()">width()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Установка ширины элемента:
<pre>// javascript
rect.width(200)</pre><br>

<pre id="3width_get"><span class="lnk" onmouseover="show('width - ширина')" onmouseout="hide()">width()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
<pre>// javascript
var width = rect.width()</pre><br>

<pre id="3height_set"><span class="lnk" onmouseover="show('height - высота')" onmouseout="hide()">height()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Установка высоты элемента:
<pre>// javascript
rect.height(325)</pre><br>

<pre id="3height_get"><span class="lnk" onmouseover="show('height - высота')" onmouseout="hide()">height()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
<pre>// javascript
rect.height()</pre><br>

<pre id="3radius"><span class="lnk" onmouseover="show('radius - радиус')" onmouseout="hide()">radius()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>radius()</tt> могут использовать окружности, эллипсы и прямоугольники. В прямоугольниках этот аргумент определяет закругление углов.<br>
Для окружности аргумент устанавливает атрибут <tt>r</tt> - радиус.
<pre>// javascript
circle.radius(10)</pre>
Для эллипсов и прямоугольников передается два аргумента по установке отдельных атрибутов <tt>rx</tt> и <tt>ry</tt>. Или передается один аргумент, означающий что оба атрибута равны между собой.
<pre>// javascript
ellipse.radius(10, 20)
rect.radius(5)</pre></div><br><br>


<h4 id="4">Синтаксический "сахар"</h4>
<div class=note_trans><b>Примечание переводчика:</b> <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80" target="_blank">Синтаксический сахар</a> (англ. syntactic sugar) в языке программирования
— это синтаксические возможности, применение которых не влияет на поведение программы, но делает использование языка более удобным для человека.<br>
Это может быть любой элемент синтаксиса, который даёт программисту альтернативный способ записи уже имеющейся в языке синтаксической конструкции,
и при этом является более удобным, или более кратким, или похожим на другой распространённый способ записи, или помогает писать программы в хорошем стиле.</div>
<div class=blockindent><br>
<pre id="4fill"><span class="lnk" onmouseover="show('fill - заполнение, заливка')" onmouseout="hide()">fill()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Метод <tt>fill()</tt> является хорошей альтернативой методу <tt>attr()</tt>:
<pre>// javascript
rect.fill({ color: '#f06', opacity: 0.6 })</pre>
Также будет работать и одно шестнадцатиричное строковое значение:
<pre>// javascript
rect.fill('#f06')</pre>
И последнее, но не менее важное; в качестве заливки также можно использовать картинку, просто передав URL-адрес изображения:
<pre>// javascript
rect.fill('images/shade.jpg')</pre>
Или, если нужно управлять размером изображения, можно передать картинку вот так:
<pre>// javascript
rect.fill(draw.image('images/shade.jpg', 20, 20))</pre><br>

<pre id="4stroke"><span class="lnk" onmouseover="show('stroke - штриховать')" onmouseout="hide()">stroke()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Метод <tt>stroke()</tt> аналогичен методу <tt>fill()</tt>:
<pre>// javascript
rect.stroke({ color: '#f06', opacity: 0.6, width: 5 })</pre>
Как и у метода <tt>fill()</tt>, здесь будет работать одиночное шестнадцатиричное строковое значение:
<pre>// javascript
rect.stroke('#f06')</pre>
Также нет отличий от метода <tt>fill()</tt> и в использовании картинки при штриховке, простая передача URL-адреса изображения:
<pre>// javascript
rect.stroke('images/shade.jpg')</pre>
Или, если нужно управлять размером изображения, можно передать картинку вот так:
<pre>// javascript
rect.stroke(draw.image('images/shade.jpg', 20, 20))</pre><br>

<pre id="4opacity"><span class="lnk" onmouseover="show('opacity - непрозрачность')" onmouseout="hide()">opacity()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Метод для установки общей непрозрачности элемента:
<pre>// javascript
rect.opacity(0.5)</pre>
</div><br><br>


<h4 id="5">Трансформация</h4>
<div class=blockindent><br>
<pre id="5transform_set"><span class="lnk" onmouseover="show('transform - преобразование')" onmouseout="hide()">transform()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
В качестве установщика данный метод имеет два способа работы. По умолчанию трансформации/преобразования являются абсолютными. Например, если вызвать:
<pre>// javascript
element.transform({ rotation: 125 }).transform({ rotation: 37.5 })</pre>
То результирующий угол поворота будет равен <tt>37.5</tt>, а не сумме двух преобразований. Но, если нужен именно суммарный поворот, выход есть, просто добавьте параметр <tt>relative</tt>. Это будет выглядеть так:
<pre>// javascript
element.transform({ rotation: 125 }).transform({ rotation: 37.5, relative: true })</pre>
Кроме того, флаг относительности (<tt>relative</tt>) может быть передан и как второй аргумент:
<pre>// javascript
element.transform({ rotation: 125 }).transform({ rotation: 37.5 }, true)</pre>

Доступные преобразования:<br>
&nbsp; &#9679; &nbsp; <tt>rotation</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>scale</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>scaleX</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>scaleY</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>skewX</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>skewY</tt> с дополнительными <tt>cx</tt> и <tt>cy</tt><br>
&nbsp; &#9679; &nbsp; <tt>x</tt><br>
&nbsp; &#9679; &nbsp; <tt>y</tt><br>
&nbsp; &#9679; &nbsp; <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, <tt>d</tt>, <tt>e</tt> и/или <tt>f</tt> или существующая матрица вместо объекта.<br><br>

<pre id="5transform_get"><span class="lnk" onmouseover="show('transform - преобразование')" onmouseout="hide()">transform()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value)</div>
Метод <tt>transform()</tt> без аргументов действует как полноценный получатель (геттер).
<pre>// javascript
element.transform()</pre>
Возвращаемый <tt>object</tt> содержит следующие значения:<br>
&nbsp; &#9679; &nbsp; <tt>x</tt> (перемещение по оси <tt>x</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>y</tt> (перемещение по оси <tt>y</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>skewX</tt> (рассчитанный наклон по оси <tt>x</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>skewY</tt> (рассчитанный наклон по оси <tt>y</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>scaleX</tt> (рассчитанный масштаб по оси <tt>x</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>scaleY</tt> (рассчитанный масштаб по оси <tt>y</tt>)<br>
&nbsp; &#9679; &nbsp; <tt>rotation</tt> (рассчитанный поворот)<br>
&nbsp; &#9679; &nbsp; <tt>cx</tt> (координата по оси <tt>x</tt> последнего центра поворота)<br>
&nbsp; &#9679; &nbsp; <tt>cy</tt> (координата по оси <tt>y</tt> последнего центра поворота)<br>
Кроме того, для нужного свойства можно передать строковое значение:<br>
<pre>// javascript
element.transform('rotation')</pre><br>

<pre id="5flip"><span class="lnk" onmouseover="show('flip - переворот')" onmouseout="hide()">flip()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Переворачивает элемент вокруг заданной оси:
<pre>// javascript
element.flip('x')</pre>
или
<pre>// javascript
element.flip('y')</pre>
По умолчанию, элементы переворачиваются вокруг своей центральной точки. Позицию осевого переворота можно определять вторым аргументом:
<pre>// javascript
element.flip('x', 150)</pre>
или
<pre>// javascript
element.flip('y', 100)</pre>
Наконец, также можно переворачивать элемент сразу вокруг обоих осей не указывая значения оси.
<pre>// javascript
element.flip()</pre>
А переворот вокруг обоих осей с одинаковым смещением можно сделать, передав только одно числовое значение:
<pre>// javascript
element.flip(5)</pre><br>

<pre id="5rotate"><span class="lnk" onmouseover="show('rotate - поворот')" onmouseout="hide()">rotate()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>rotate()</tt> автоматически поворачивает элементы в соответствии с центральной точкой элемента:
<pre>// javascript
// rotate(degrees)
element.rotate(45)</pre>
Хотя также можно определить и конкретную точку поворота:
<pre>// javascript
// rotate(degrees, cx, cy)
element.rotate(45, 50, 50)</pre><br>

<pre id="5skew"><span class="lnk" onmouseover="show('skew - наклон')" onmouseout="hide()">skew()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>skew()</tt> (наклон) принимает значения <tt>x</tt> и <tt>y</tt>.
<pre>// javascript
// skew(x, y)
element.skew(0, 45)</pre><br>

<pre id="5scale"><span class="lnk" onmouseover="show('scale - масштаб')" onmouseout="hide()">scale()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>scale()</tt> принимает значения <tt>x</tt> и <tt>y</tt>.
<pre>// javascript
// scale(x, y)
element.scale(0.5, -1)</pre><br>

<pre id="5translate"><span class="lnk" onmouseover="show('translate - перевод, перенос')" onmouseout="hide()">translate()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
<div class=list>анимируется - да</div>
Метод <tt>translate()</tt> принимает значения <tt>x</tt> и <tt>y</tt>.
<pre>// javascript
// translate(x, y)
element.translate(0.5, -1)</pre></div><br><br>


<h4 id="6">Стили</h4>
<div class=blockindent><br>
<pre id="6style_set"><span class="lnk" onmouseover="show('style - стиль')" onmouseout="hide()">style()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
С помощью метода <tt>style()</tt> можно управлять атрибутом <tt>style</tt> также как атрибутами с помощью <tt>attr</tt>:
<pre>// javascript
element.style('cursor', 'pointer')</pre>
Несколько стилей могут быть установлены одновременно, если в качестве аргумента использовать объект:
<pre>// javascript
element.style({ cursor: 'pointer', fill: '#f03' })</pre>
Или css-строку:
<pre>// javascript
element.style('cursor:pointer;fill:#f03;')</pre>
Прямое удаление отдельных стилевых определений работает точно также как у метода <tt>attr()</tt>:
<pre>// javascript
element.style('cursor', null)</pre><br>

<pre id="6style_get"><span class="lnk" onmouseover="show('style - стиль')" onmouseout="hide()">transform()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (value) (строку (string), число (number), ...)</div>
Аналогично методу <tt>attr()</tt>, метод <tt>style()</tt> также может действовать как получатель (геттер):
<pre>// javascript
element.style('cursor')
// => pointer (указатель)</pre>
Или даже как полный получатель:
<pre>// javascript
element.style()
// => 'cursor:pointer;fill:#f03;'</pre><br>

<pre id="6hide"><span class="lnk" onmouseover="show('hide - скрыть, спрятать')" onmouseout="hide()">hide()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Скрыть элемент:
<pre>// javascript
element.hide()</pre><br>

<pre id="6show"><span class="lnk" onmouseover="show('show - показать, вывести, предъявить')" onmouseout="hide()">show()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Показать (отобразить) элемент:
<pre>// javascript
element.show()</pre><br>

<pre id="6visible"><span class="lnk" onmouseover="show('visible - видимый, отображаемый')" onmouseout="hide()">visible()</span></pre>
<div class=list>возвращает - логическое значение (boolean)</div>
Метод для проверки, является ли элемент видимым:
<pre>// javascript
element.visible()</pre></div><br>


<h4 id="7">Классы</h4>
<div class=blockindent><br>
<pre id="7addClass"><span class="lnk" onmouseover="show('add class - добавить класс')" onmouseout="hide()">addClass()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Добавляет заданный класс CSS:
<pre>// javascript
element.addClass('pink-flower')</pre><br>

<pre id="7classes"><span class="lnk" onmouseover="show('classes - классы')" onmouseout="hide()">classes()</span></pre>
<div class=list>возвращает - массив (array)</div>
Получает классы CSS для узла в виде массива:
<pre>// javascript
element.classes()</pre><br>

<pre id="7hasClass"><span class="lnk" onmouseover="show('has class - имеет класс')" onmouseout="hide()">hasClass()</span></pre>
<div class=list>возвращает - логическое значение (boolean)</div>
Проверяет наличие заданного класса CSS:
<pre>// javascript
element.hasClass('purple-rain')</pre><br>

<pre id="7removeClass"><span class="lnk" onmouseover="show('remove class - удалить класс')" onmouseout="hide()">removeClass()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Удаляет заданный класс CSS:
<pre>// javascript
element.removeClass('pink-flower')</pre><br>

<pre id="7toggleClass"><span class="lnk" onmouseover="show('toggle class - переключает класс')" onmouseout="hide()">toggleClass()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Переключает заданный класс CSS:
<pre>// javascript
element.toggleClass('pink-flower')</pre></div><br><br>


<h4 id="8">Данные</h4>
Метод <tt>data()</tt> позволяет связывать произвольные объекты, строки и числа с элементами SVG.
<div class=blockindent><br>
<pre id="8data_get"><span class="lnk" onmouseover="show('data - данные')" onmouseout="hide()">data()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (<tt>value</tt>)</div>
Получает значения аналогично методу <tt>attr()</tt>:
<pre>// javascript
var key = rect.data('key')</pre><br>

<pre id="8data_set"><span class="lnk" onmouseover="show('data - данные')" onmouseout="hide()">data()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>

<pre>// javascript
rect.data('key', { value: { data: 0.3 }})</pre>
Или устанавливает сразу несколько значений:
<pre>// javascript
rect.data({
  forbidden: 'fruit'
, multiple: {
    values: 'in'
  , an: 'object'
  }
})</pre>
Полное удаление данных:
<pre>// javascript
rect.data('key', null)</pre>
Значения всегда будут храниться в формате JSON и в некоторых случаях это может быть нежелательно. Если нужно сохранить значение как есть, просто передайте <tt>true</tt> в качестве третьего аргумента:
<pre>// javascript
rect.data('key', 'value', true)</pre></div><br><br>


<h4 id="9">Память</h4>
<div class=blockindent><br>
<pre id="9remember_get"><span class="lnk" onmouseover="show('remember - вспомнить')" onmouseout="hide()">remember()</span>          <i class=low>как получатель (геттер)</i></pre>
<div class=list>возвращает значение (<tt>value</tt>)</div>
Для восстановления памяти
<pre>// javascript
rect.remember('oldBBox')</pre><br>

<pre id="9remember_set"><span class="lnk" onmouseover="show('remember - запомнить')" onmouseout="hide()">remember()</span>          <i class=low>как установщик (сеттер)</i></pre>
<div class=list>возвращает - самого себя (itself)</div>
Сохранение данных в памяти очень похоже на установку атрибутов:
<pre>// javascript
rect.remember('oldBBox', rect.bbox())</pre>
Также можно запоминать несколько значений сразу:
<pre>// javascript
rect.remember({
  oldFill:    rect.attr('fill')
, oldStroke:  rect.attr('stroke')
})</pre><br>

<pre id="9forget"><span class="lnk" onmouseover="show('forget - забыть')" onmouseout="hide()">forget()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Стирание одного значения в памяти:
<pre>// javascript
rect.forget('oldBBox')</pre>
Или стирание сразу нескольких значений в памяти:
<pre>// javascript
rect.forget('oldFill', 'oldStroke')</pre>
И наконец, просто стереть всю память целиком:
<pre>// javascript
rect.forget()</pre></div><br><br>


<h4 id="10">"Дерево" документа</h4>
<div class=blockindent><br>
<pre id="10add"><span class="lnk" onmouseover="show('add - добавить')" onmouseout="hide()">add()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Устанавливает вызывающий элемент (в примере это <tt>group</tt>) в качестве родительского узла для аргумента (т.е. <tt>rect</tt>). Возвращает родительский элемент:
<pre>// javascript
var rect = draw.rect(100, 100)
var group = draw.group()<br>
group.add(rect) // -> returns group (возвращает группу)</pre><br>

<pre id="10addTo"><span class="lnk" onmouseover="show('add to - добавить в ...')" onmouseout="hide()">addTo()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Устанавливает вызывающий элемент как дочерний узел аргумента. Возвращает дочерний элемент:
<pre>// javascript
rect.addTo(group) // -> returns rect (возвращает элемент rect)</pre><br>

<pre id="10clone"><span class="lnk" onmouseover="show('clone - клон, штамп')" onmouseout="hide()">clone()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Метод <tt>clone()</tt> удобно использовать для получения точной копии элемента:
<pre>// javascript
var clone = rect.clone()</pre>
Данный метод создает новую, несвязанную копию. Чтобы сделать связанную копию, смотрите элемент <tt><a href="elements.htm#17" onmouseover="show('Элементы / SVG.Use')" onmouseout="hide()">use</a></tt>.<br>
По умолчанию клонированный элемент размещается непосредственно после исходного элемента.
При передаче методу <tt>clone()</tt> параметра с родительским элементом, он добавит клонированный элемент к заданному родительскому элементу.<br><br>

<pre id="10put"><span class="lnk" onmouseover="show('put - положить')" onmouseout="hide()">put()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Устанавливает вызывающий элемент (в примере это <tt>group</tt>) в качестве родительского узла для аргумента (т.е. <tt>rect</tt>). Возвращает дочерний элемент:
<pre>// javascript
group.put(rect) // -> returns rect (возвращает элемент rect)</pre><br>

<pre id="10putIn"><span class="lnk" onmouseover="show('put in - положить в ...')" onmouseout="hide()">putIn()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Устанавливает вызывающий элемент (в примере это <tt>rect</tt>) в качестве дочернего узла для аргумента (т.е. для <tt>group</tt>). Возвращает родительский элемент:
<pre>// javascript
rect.putIn(group) // -> returns group (возвращает группу)</pre><br>

<pre id="10remove"><span class="lnk" onmouseover="show('remove - удалить')" onmouseout="hide()">remove()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Удаляет вызывающий элемент из svg-документа:
<pre>// javascript
rect.remove()</pre><br>

<pre id="10replace"><span class="lnk" onmouseover="show('replace - заменять, замещать')" onmouseout="hide()">replace()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
В позиции вызывающего элемента в svg-документе, вызывающий элемент (в примере это <tt>rect</tt>) заменяется элементом, переданным методу (в примере это <tt>circle</tt>).
<pre>// javascript
rect.replace(draw.circle(100))</pre><br>

<pre id="10toDoc"><span class="lnk" onmouseover="show('to doc - в документ')" onmouseout="hide()">toDoc()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Тоже самое, что и <tt>toParent()</tt>, но с коренным узлом в качестве родительского.<br><br>

<pre id="10toParent"><span class="lnk" onmouseover="show('to parent - ')" onmouseout="hide()">toParent()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Перемещает элемент к другому родителю (аналогично <tt>addTo</tt>), но без изменения его визуального представления. Все преобразования объединяются и применяются к элементу.
<pre>// javascript
rect.toParent(group) // looks the same as before (выглядит так же, как и раньше)</pre><br>

<pre id="10ungroup"><span class="lnk" onmouseover="show('ungroup - разгруппировать<br>flatten - выравнивать, расплющить')" onmouseout="hide()">ungroup() / flatten()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Разбивает группу/контейнер и перемещает все элементы в заданный родительский узел, не изменяя их видимого представления. Результатом является плоская структура SVG, например, для экспорта.<br><br>
Рекурсивно разгруппировывает все элементы в этой группе и помещает их в заданного родителя.
<pre>// javascript
group.ungroup(parent, depth)
// (default: parent container of the calling element)
// (по умолчанию: родительский контейнер вызывающего элемента)</pre>
Вызов этого метода на весь документ целиком для получения "плоской" svg-структуры:
<pre>// javascript
drawing.ungroup()</pre>
Расформировываем группу (<tt>group</tt>) и помещаем все элементы в <tt>drawing</tt>.
<pre>// javascript
group.ungroup(drawing)</pre>
Расформировываем все группы до 3 уровня в глубину:
<pre>// javascript
drawing.ungroup(null, 3)</pre>
Делаем "плоским" и экспортируем svg:
<pre>// javascript
var svgString = drawing.ungroup().svg()</pre></div><br><br>


<h4 id="11">Организация элементов</h4>
Можно изменять расположение элементов в пределах их родительского SVG-документа при помощи следующих методов:
<div class=blockindent><br>
<pre id="11after"><span class="lnk" onmouseover="show('after - после, затем')" onmouseout="hide()">after()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Вставляет один элемент после другого:
<pre>// javascript
// inserts circle after rect (вставка круга после прямоугольника)
rect.after(circle)</pre><br>

<pre id="11before"><span class="lnk" onmouseover="show('before - перед, до, раньше')" onmouseout="hide()">before()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Вставляет один элемент перед другим:
<pre>// javascript
// inserts circle before rect (вставка круга перед прямоугольником)
rect.before(circle)</pre><br>

<pre id="11back"><span class="lnk" onmouseover="show('back - назад, обратно')" onmouseout="hide()">back()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Перемещает элемент в конец:
<pre>// javascript
rect.back()</pre><br>

<pre id="11backward"><span class="lnk" onmouseover="show('backward - назад, в обратном направлении')" onmouseout="hide()">backward()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Перемещает элемент на один шаг назад:
<pre>// javascript
rect.backward()</pre><br>

<pre id="11front"><span class="lnk" onmouseover="show('front - перед, передняя часть')" onmouseout="hide()">front()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Перемещает элемент в начало:
<pre>// javascript
rect.front()</pre><br>

<pre id="11forward"><span class="lnk" onmouseover="show('forward - вперед')" onmouseout="hide()">forward()</span></pre>
<div class=list>возвращает - самого себя (itself)</div>
Перемещает элемент на один шаг вперед:
<pre>// javascript
rect.forward()</pre><br>

<pre id="11next"><span class="lnk" onmouseover="show('next - следующий')" onmouseout="hide()">next()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Получает следующий, одноуровневый элемент (соседний):
<pre>// javascript
rect.next()</pre><br>

<pre id="11position"><span class="lnk" onmouseover="show('position - позиция, положение')" onmouseout="hide()">position()</span></pre>
<div class=list>возвращает  число (<tt>number</tt>)</div>
Получает позицию (в виде числа) прямоугольника (<tt>rect</tt>) среди своих соседей по уровню иерархии:
<pre>// javascript
rect.position()</pre><br>

<pre id="11previous"><span class="lnk" onmouseover="show('previous - предыдущий')" onmouseout="hide()">previous()</span></pre>
<div class=list>возвращает <tt>SVG.Element</tt></div>
Получает предыдущий, одноуровневый элемент (соседний):
<pre>// javascript
rect.previous()</pre><br>

<pre id="11siblings"><span class="lnk" onmouseover="show('siblings - одноуровневые элементы, братья и сестры, сибсы')" onmouseout="hide()">siblings()</span></pre>
<div class=list>возвращает - массив (<tt>array</tt>)</div>
Метод используется для получения всех соседних элементов, включая и сам прямоугольник <tt>rect</tt>. То есть, получаем все элементы на одном уровне с вызывающим, включая и сам вызывающий элемент.<br>
Плагин (модуль) <tt>arrange.js</tt> предоставляет несколько дополнительных методов.
<pre>// javascript
rect.siblings()</pre></div><br><br>


<h4 id="12">Геометрия</h4>
<div class=blockindent><br>
<pre id="12point"><span class="lnk" onmouseover="show('point - точка')" onmouseout="hide()">point()</span></pre>
<div class=list>возвращает - <tt><a href="classes.htm#8" onmouseover="show('SVG.Point')" onmouseout="hide()">SVG.Point</a></tt></div>
Преобразует координаты точки из системы координат экрана в систему координат элементов.
<pre>// javascript
// e is some mouseevent (e - это какое-либо "мышиное" событие)
var point = path.point(e.screenX, e.screenY) // {x, y}</pre><br>

<pre id="12inside"><span class="lnk" onmouseover="show('inside - внутри')" onmouseout="hide()">inside()</span></pre>
<div class=list>возвращает - логическое значение (boolean)</div>
Метод <tt>inside()</tt> используется для проверки, находится ли заданная точка внутри ограничительной рамки элемента:
<pre>// javascript
var rect = draw.rect(100, 100).move(50, 50)<br>
rect.inside(25, 30) // -> returns false (возвращает значение false - ложь)
rect.inside(60, 70) // -> returns true (возвращает значение true - истина)</pre>
<div class=note><b>Примечание:</b> позиция по координатам <tt>x</tt> и <tt>y</tt> проверяется относительно позиции элемента. Никакое смещение родительского элемента не учитывается.</div></div><br>

<br><br>
</body></html>
