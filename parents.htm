<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>svg.js Справочное руководство</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>

<body>
<h3>Родительские элементы</h3>

<h5>SVG.Parent</h5>
Класс <tt>SVG.Parent</tt> является базовой оболочкой для всех элементов, которые могут содержать другие элементы. <tt>SVG.Parent</tt> наследуется непосредственно от самого нижнего уровня всех классов SVG.js: <tt>SVG.Element</tt>.<br><br>

<h5>SVG.Container</h5>
<tt>SVG.Container</tt> добавляет в стек родительского наследования ещё один уровень. Куда <tt>SVG.Parent</tt> привносит некоторые низкоуровневые методы, такие как <tt>add()</tt>, <tt>remove()</tt> и <tt>has()</tt>
`SVG.Container` adds another level to the parent inheritance stack. Where `SVG.Parent` brings some low level methods like `add()`, `remove()` and `has()` to name a few, `SVG.Container` can and should be used if you want to add your own methods. That way the `SVG.Parent` prototype remains clean. Therefore you should always inherit from `SVG.Container` when implementing your own parent elements.
При реализации своих собственных родительских элементов, они всегда должны наследовать от <tt>SVG.Container</tt>.<br><br>
Стек родительского наследования: <tt>SVG.Element</tt> &#62; <tt>SVG.Parent</tt> &#62; <tt>SVG.Container</tt>.<br><br>

<h4 id="1"><span class="lnk" onmouseover="show('здесь Doc скорее всего сокращение англ. слова document - документ')" onmouseout="hide()">SVG.Doc</span></h4>
Основная функция-инициализатор в SVG.js, создает корневой svg-узел в заданном элементе и возвращает экземпляр <tt>SVG.Doc</tt>.
<pre>SVG()</pre>
<div class=list>возвращает - <tt>SVG.Doc</tt>, который наследует от <tt>SVG.Container</tt>.</div>
<pre>// javascript
var draw = SVG('drawing')</pre>
<div class=note><b>Примечание:</b> При первом вызове <tt>SVG()</tt> будет создан второй невидимый <tt>&#60;svg&#62;</tt>.
Это наш <span class="lnk" onmouseover="show('от англ. слова parser - синтаксический анализатор')" onmouseout="hide()">"парсер"</span>, как описано в <a href="faq.htm#1">ЧАсто задаваемых ВОпросах</a>.</div><br>

<h4 id="2"><span class="lnk" onmouseover="show('nested - вложенный')" onmouseout="hide()">SVG.Nested</span></h4>
Вкладывает SVG-документы друг в друга.
<div class=blockindent><br>
<pre id="2nested"><span class="lnk" onmouseover="show('nested - вложенный')" onmouseout="hide()">nested()</span> <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Nested</tt>, который наследует от <tt>SVG.Container</tt>.</div>
Вложенные SVG-документы имеют точно такие же функции, как и основной SVG-документ верхнего уровня:
<pre>var nested = draw.nested()<br>
var rect = nested.rect(200, 200)</pre></div><br>

<h4 id="3"><span class="lnk" onmouseover="show('G скорее всего сокращение англ. слова Group - группа')" onmouseout="hide()">SVG.G</span></h4>
Группирование элементов может быть полезно, если нужно изменять набор элементов, как если бы он был одним элементом. Все элементы в группе сохраняют свою позицию относительно группы, к которой они принадлежат.
<div class=note><b>Примечание:</b> Группы не имеют собственных геометрических данных, они наследуется от их содержимого.
Поэтому для группы нельзя получить атрибуты <tt><span class="lnk" onmouseover="show('координата x')" onmouseout="hide()">x</span></tt>, <tt><span class="lnk" onmouseover="show('координата y')" onmouseout="hide()">y</span></tt>,
<tt><span class="lnk" onmouseover="show('width - ширина')" onmouseout="hide()">width</span></tt> и <tt><span class="lnk" onmouseover="show('height - высота')" onmouseout="hide()">height</span></tt>.
Если вы ищете именно, используйте взамен вложенный svg - <tt>nested()</tt>.</div>
<div class=blockindent><br>
<pre id="3group"><span class="lnk" onmouseover="show('group - группа')" onmouseout="hide()">group()</span> <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.G</tt>, который наследует от <tt>SVG.Container</tt>.</div>
Группа имеет те же самые методы элемента, что и корневой SVG-документ:
<pre>var group = draw.group()
group.path('M10,20L30,40')</pre>
Элементы, уже существующие в SVG-документе, также могут быть добавлены в группу:
<pre>group.add(rect)</pre></div><br>

<h4 id="4">SVG.Symbol</h4>
<div class=blockindent><br>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Symbol</tt>, который наследует от <tt>SVG.Container</tt>.</div>
В отличие от элемента <tt>group</tt>, элемент <tt>symbol</tt> является контейнерным элементом. Единственная разница между символами и группами заключается в том, что символы не отображаются. Поэтому элемент <tt>symbol</tt> идеален в сочетании с элементом <tt>use</tt>:
<pre>var symbol = draw.symbol()
symbol.rect(100, 100).fill('#f09')<br>
var use  = draw.use(symbol).move(200, 200)</pre></div><br>


<h4 id="5">SVG.Defs</h4>
Элемент <tt>&#60;defs&#62;</tt> является контейнером для элементов, на которые ссылаются. Потомки узла <tt>&#60;defs&#62;</tt> не отображаются напрямую.
Узел <tt>&#60;defs&#62;</tt> живет в основном документе <tt>&#60;svg&#62;</tt> и к нему можно обращаться с помощью метода <tt>defs()</tt>.
The <tt>&#60;defs&#62;</tt> element is a container for referenced elements. Descendants of a `&#60;defs&#62;`node are not rendered directly. The `&#60;defs&#62;` node lives in the main `&#60;svg&#62;` document and can be accessed with the `defs()` method.
<div class=blockindent><br>
<pre id="5defs"><span class="lnk" onmouseover="show('defs - сокращ. англ. слова definitions - определения')" onmouseout="hide()">defs()</span> <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.Defs</tt>, который наследует от <tt>SVG.Container</tt>.</div>

<pre>// javascript
var defs = draw.defs()</pre>
Определения (defs) также доступны от любого другого элемента через метод <tt>doc()</tt>:
The defs are also available on any other element through the `doc()` method:

<pre>// javascript
var defs = rect.doc().defs()</pre>
Узел (нода) определений (defs) работает точно также, как и группы.
The defs node works exactly the same as groups.</div><br><br>

<h4 id="6">SVG.A</h4>
Создает гиперссылку, которая будет активирована на всех дочерних элементах.
<div class=blockindent><br>
<pre id="6link"><span class="lnk" onmouseover="show('link - ссылка, соединение, звено')" onmouseout="hide()">link()</span>  <i class=low>конструктор</i></pre>
<div class=list>конструктор на <tt>SVG.Container</tt></div>
<div class=list>возвращает - <tt>SVG.A</tt>, который наследует от <tt>SVG.Container</tt>.</div>
Гиперссылка или тег <tt>&#60;a&#62;</tt> создает контейнер, который включает ссылку на все дочерние элементы:
<pre>var link = draw.link('http://svgdotjs.github.io/')
var rect = link.rect(100, 100)</pre>
URL-адрес ссылки может быть обновлен методом <tt>to()</tt>:
<pre>link.to('http://apple.com')</pre>
Кроме того, у элемента <tt>link</tt> имеется метод <tt>show()</tt> для создания атрибута <tt>xlink:show</tt>:
<pre>link.show('replace')</pre>
И метод <tt>target()</tt> для создания атрибута <tt>target</tt>:
<pre>link.target('_blank')</pre>
Также, элементы могут быть связаны другим способом, с помощью метода <tt>linkTo()</tt>:
<pre>rect.linkTo('http://svgdotjs.github.io/')</pre>
Кроме того, блок может быть передан вместо URL-адреса для дополнительных параметров элемента ссылки:
Alternatively, a block can be passed instead of a URL for more options on the link element:

<pre>rect.linkTo(function(link) {
  link.to('http://svgdotjs.github.io/').target('_blank')
})</pre></div><br>


<br><br>
</body></html>
