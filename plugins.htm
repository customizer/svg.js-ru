<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>svg.js Справочное руководство</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="1.css">
<script type="text/javascript" src="1.js"></script>
</head>

<body>
<h3>Плагины (модули)</h3>
Вот список всех доступных плагинов для SVG.js с краткими пояснениями. Если вы написали что-то ещё, пожалуйста, дайте нам знать!
<div class=blockindent><br>
&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-colorat-js/" target="_blank" id="1">svg.colorat.js</a></tt><br>
<div class=indent1>Плагин <a href="https://github.com/svgdotjs/svg.colorat.js" target="_blank">svg.colorat.js</a> - это расширение для библиотеки SVG.js, которое позволяет выбрать цвет градиента в определенной заданной позиции.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Расширение для библиотеки SVG.js, которое позволяет выбрать цвет градиента в определенной заданной позиции.<br>
Демонстрацию можно увидеть на <a href="https://jsfiddle.net/wout/sn7um5fr/" target="_blank" onclick='no_js(event)'>этой странице</a>.
 
<h3>Начало работы</h3>
Установите svg.colorAt.js при помощи bower или npm:
<pre>bower install svg.colorat.js
npm install svg.colorat.js</pre>
Подключите его в своем html-документе, после подключения библиотеки svg.js.
<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.colorAt.js"&#62;&#60;/script&#62;</pre>
Пользуйтесь:
<pre>&#60;div id="drawing"&#62;&#60;/div&#62;</pre>

<pre>var draw = SVG('drawing')

var gradient = draw.gradient('linear', function(stop) {
  stop.at(0, '#799abc')
  stop.at(0.5, '#ccc')
  stop.at(1, '#e88081')
})

var rect = draw.rect(100, 100).move(10, 10).fill(gradient)

draw.circle(10).center(10, 120).fill(gradient.colorAt(0))
draw.circle(10).center(35, 120).fill(gradient.colorAt(0.25))
draw.circle(10).center(60, 120).fill(gradient.colorAt(0.5))
draw.circle(10).center(85, 120).fill(gradient.colorAt(0.75))
draw.circle(10).center(110, 120).fill(gradient.colorAt(1))</pre></div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-connectable-js/" target="_blank" id="2">svg.connectable.js</a></tt><br>
<div class=indent1>Плагин <a href="https://github.com/jillix/svg.connectable.js" target="_blank">svg.connectable.js</a> для соединения элементов. (автор плагина jillix)</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Библиотека JavaScript для соединения SVG элементов.<br>

<h3><a href="https://ru.wikipedia.org/wiki/Content_Delivery_Network" target="_blank" onclick='no_js(event)' onmouseover="show('Сеть доставки (и дистрибуции) содержимого (англ. Content Delivery Network<br>или Content Distribution Network, CDN) — географически распределённая<br>сетевая инфраструктура, позволяющая оптимизировать доставку и дистрибуцию<br>содержимого конечным пользователям в сети Интернет. Использование<br>контент-провайдерами CDN способствует увеличению скорости загрузки<br>интернет-пользователями аудио-, видео-, программного, игрового и других<br>видов цифрового содержимого в точках присутствия сети CDN.')" onmouseout="hide()">CDN</a></h3>
Библиотека также доступна на <a href="https://cdnjs.com/libraries/svg.connectable.js" target="_blank" onclick='no_js(event)'>CDNJS</a>. Чтобы использовать её, просто сделайте так:
<pre>&#60;script src="https://cdnjs.cloudflare.com/ajax/libs/svg.connectable.js/2.0.1/svg.connectable.min.js"&#62;&#60;/script&#62;</pre>

<h3>Использование</h3>
Работа данной библиотеки зависит от наличия:<br>
&nbsp; &#9679; &nbsp; SVG.js<br>
&nbsp; &#9679; &nbsp; svg.draggy.js<br>

<pre>&#60;script src="path/to/svg.js"&#62;&#60;/script&#62;
&#60;script src="path/to/svg.draggy.js"&#62;&#60;/script&#62;
&#60;script src="path/to/svg.connectable.js"&#62;&#60;/script&#62;
&#60;!-- Or from CDN (Или из CDN)
&#60;script src="https://cdnjs.cloudflare.com/ajax/libs/svg.connectable.js/2.0.1/svg.connectable.min.js"&#62;&#60;/script&#62;
--&#62;
&#60;div class="graph"&#62;&#60;/div&#62;
&#60;script&#62;
    var svg = new SVG(document.querySelector(".graph")).size("100%", 500);
    var links = svg.group();
    var markers = svg.group();
    var nodes = svg.group();

    var g1 = nodes.group().translate(300, 200).draggy();
    g1.circle(80).fill("#C2185B");

    var g2 = nodes.group().translate(100, 200).draggy();
    g2.circle(50).fill("#E91E63");

    var g3 = nodes.group().translate(200, 400).draggy();
    g3.circle(100).fill("#FF5252");

    g1.connectable({
        container: links,
        markers: markers
    }, g2).setLineColor("#5D4037");

    g2.connectable({
        padEllipse: true
    }, g3).setLineColor("#5D4037")
&#60;/script&#62;</pre>
Этот демонстрационный пример на jsfiddle: <a href="https://jsfiddle.net/u8qck0h3/" target="_blank" onclick='no_js(event)'>https://jsfiddle.net/u8qck0h3/</a>.<br><br>

<h4>Документация</h4>
<code>connectable(options, elmTarget)</code><br>
Соединяет два элемента. Если вызвать несколько раз, линии будут кривыми.
Connects two elements. If called multiple times, the lines will be curved.
<div class=list>
<h5>Параметры</h5>

    Object options: An object containing the following fields:
&nbsp; &#9679; &nbsp; container (SVGElement): The line elements container.<br>
&nbsp; &#9679; &nbsp; markers (SVGElement): The marker elements container.<br>
&nbsp; &#9679; &nbsp; padEllipse (Boolean): If true, the line coordinates will be placed with a padding.<br>
&nbsp; &#9679; &nbsp; SVGElement elmTarget: The target SVG element.<br>

<h5>Возврат</h5>

    Object The connectable object containing:
&nbsp; &#9679; &nbsp; source (SVGElement): The source element.<br>
&nbsp; &#9679; &nbsp; target (SVGElement): The target element.<br>
&nbsp; &#9679; &nbsp; line (SVGElement): The line element.<br>
&nbsp; &#9679; &nbsp; marker (SVGElement): The marker element.<br>
&nbsp; &#9679; &nbsp; computeLineCoordinates (Function)<br>
&nbsp; &#9679; &nbsp; update (Function)<br>
&nbsp; &#9679; &nbsp; setLineColor (Function)</div><br><br>

<code>computeLineCoordinates(con)</code><br>

The function that computes the new coordinates. It can be overriden with a custom function.
<div class=list>
<h5>Параметры</h5>
&nbsp; &#9679; &nbsp; Connectable con: The connectable instance.
<h5>Возврат</h5>
&nbsp; &#9679; &nbsp; Object An object containing the x1, x2, y1 and y2 coordinates.</div><br><br>

<code>update()</code><br>
Обновляет координаты линии.<br><br>

<code>setLineColor(color, c)</code><br>
Устанавливает цвет линии.
<div class=list>
<h5>Параметры</h5>
&nbsp; &#9679; &nbsp; String color: The new color.<br>
&nbsp; &#9679; &nbsp; Connectable c: The connectable instance.</div><br><br>

<h4>Как принять участие</h4>
Есть идея? Нашли ошибку? Посмотрите <a href="https://github.com/jillix/svg.connectable.js/blob/master/CONTRIBUTING.md" target="_blank" onclick='no_js(event)'>как принять участие</a>.<br><br>

<h4>Лицензия</h4>
Смотрите файл <a href="https://github.com/jillix/svg.connectable.js/blob/master/LICENSE" target="_blank" onclick='no_js(event)'>лицензии</a>.<br><br></div></div>

<div class=indent1><a href="https://github.com/loredanacirstea/svg.connectable.js" target="_blank">svg.connectable.js fork</a> для соединения SVG элементов (автор плагина loredanacirstea)<br>
added: curved connectors, you can use any self-made path as a connector, choosable 'center'/'perifery' attachment, 'perifery' attachment for source / target SVG Paths uses smallest-distance algorithm between PathArray points</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Библиотека JavaScript для соединения SVG элементов.<br><br>

<h4>Использование</h4>

Following example can be tested in the following jsfiddle: https://jsfiddle.net/L2sjjc3b/80/<br>

Example source code also in https://github.com/loredanacirstea/svg.connectable.js/tree/master/example.<br>

Работа данной библиотеки зависит от наличия:<br>
&nbsp; &#9679; &nbsp; SVG.js<br>
&nbsp; &#9679; &nbsp; svg.draggy.js (note this is the @jillix fork of the original svg.draggable.js project)<br>


Different from original jillix library:<br>

&nbsp; &#9679; &nbsp; the connector can be any SVG Path element defined through use() (usually connectors are reused). See example. Note the two M points added for attachment precision.<br>
&nbsp; &#9679; &nbsp; you can define the type of attachment (center, perifery) separate for source and target<br>
&nbsp; &#9679; &nbsp; you can have straight/curved connectors - available for the 'default' connector.<br>
&nbsp; &#9679; &nbsp; functions for changing the connection settings after initializing it.<br>
&nbsp; &#9679; &nbsp; padEllipse function from jillix is used automatically for ellipses ('perifery' attachment).<br>

<h4>Документация</h4>
<code>connectable(options, elmTarget)</code><br>
Соединяет два элемента.
<div class=list>
<h5>Параметры</h5>

    Object options: An object containing any of the following fields:<br>
&nbsp; &#9679; &nbsp; container (SVGElement): The connector elements container. Defaults to source parent.<br>
&nbsp; &#9679; &nbsp; markers (SVGElement): The marker elements container. Defaults to source parent.<br>
&nbsp; &#9679; &nbsp; sourceAttach (String): Connector attachment for source element: 'center' / 'perifery'. Defaults to 'center'<br>
&nbsp; &#9679; &nbsp; targetAttach (String): Connector attachment for target element: 'center' / 'perifery'. Defaults to 'center'<br>
&nbsp; &#9679; &nbsp; type (String): Connector type: 'straight' or 'curved'. Defaults to 'straight'<br>
&nbsp; &#9679; &nbsp; marker (String/SVGElement): Can be: an SVGElement / 'null' / 'default'. Defaults to 'null'<br>
&nbsp; &#9679; &nbsp; color (String): Connector color. Defaults to '#000000'<br>
&nbsp; &#9679; &nbsp; SVGElement elmTarget: The target SVG element.<br>

<h5>Возврат</h5>

    Object The connectable object containing:<br>
&nbsp; &#9679; &nbsp; source (SVGElement): The source element.<br>
&nbsp; &#9679; &nbsp; target (SVGElement): The target element.<br>
&nbsp; &#9679; &nbsp; connector (SVGElement): The connector element.<br>
&nbsp; &#9679; &nbsp; marker (SVGElement): The marker element.<br>
&nbsp; &#9679; &nbsp; computeConnectorCoordinates (Function)<br>
&nbsp; &#9679; &nbsp; update (Function)<br>
&nbsp; &#9679; &nbsp; setConnectorColor (Function)<br>
&nbsp; &#9679; &nbsp; setMarker (Function)<br>
&nbsp; &#9679; &nbsp; setConnectorAttachment (Function)<br>
&nbsp; &#9679; &nbsp; setConnector (Function)<br>
&nbsp; &#9679; &nbsp; setType (Function)</div><br><br>

<code>computeConnectorCoordinates(con)</code><br>
Функция, которая вычисляет новые координаты.
The function that computes the new coordinates. It can be overriden with a custom function.
<div class=list>
<h5>Параметры</h5>
&nbsp; &#9679; &nbsp; Connectable con: The connectable instance.<br>
<h5>Возврат</h5>
&nbsp; &#9679; &nbsp; Object Returns the new SVG PathArray for the connector.</div><br><br>

<code>update()</code><br>
Обновляет координаты линии.<br><br>

<code>setConnectorColor(color, c)</code><br>
Устанавливает цвет соединителя и маркера.
<div class=list>
<h5>Параметры</h5>
&nbsp; &#9679; &nbsp; String color: The new color.<br>
&nbsp; &#9679; &nbsp; Connectable c: The connectable instance. Optional</div><br><br>

<code>setMarker(marker, markers, c)</code><br>
Устанавливает маркер.
<div class=list>
<h5>Параметры</h5>
&nbsp; &#9679; &nbsp; SVGElement/String marker: New marker element / 'null' / 'default'.<br>
&nbsp; &#9679; &nbsp; SVGElement markers: Group parent for markers. Defaults to source.parent<br>
&nbsp; &#9679; &nbsp; Connectable c: The connectable instance. Optional.</div><br><br>

<code>setConnectorAttachment(element, type, c)</code><br>

Sets the connector's type of attachment.
<div class=list>
<h5>Параметры</h5>

&nbsp; &#9679; &nbsp; String element: 'source' / 'target'<br>
&nbsp; &#9679; &nbsp; String type: 'center' / 'perifery'. For paths, the 'perifery' option takes the PathArray point which is closest to the source/target attachment point. For ellipses, it uses the jillix algorithm for padEllipse (padding area aorund the ellipse). For all other, it uses the 4 middle side points from the bbox() rectangle.<br>
&nbsp; &#9679; &nbsp; Connectable c: The connectable instance. Optional.</div><br><br>

<code>setConnector(connector, c)</code><br>
Устанавливает соединитель.

<div class=list>
<h5>Параметры</h5>

&nbsp; &#9679; &nbsp; SVGElement/String connector: New connector element / 'default'.
&nbsp; &#9679; &nbsp; Connectable c: The connectable instance. Optional.</div><br><br>

<code>setType(type, c)</code><br>

Sets the connector and marker color.
<div class=list>
<h5>Параметры</h5>
&nbsp; &#9679; &nbsp; String type: Connector type for default connector: 'straight' / 'curved'. Defaults to 'straight'
&nbsp; &#9679; &nbsp; Connectable c: The connectable instance. Optional.</div><br><br>

<h4>Как принять участие</h4>

&nbsp; 1. &nbsp; File an issue in the repository and provide an example for it (you can fork the example jsfiddle to reproduce the bug) or:<br>
&nbsp; 2. &nbsp; Fork the project in your account and create a new branch: your-great-feature.<br>
&nbsp; 3. &nbsp; Commit your changes in that branch.<br>
&nbsp; 4. &nbsp; Open a pull request, and reference the initial issue in the pull request message.<br><br>

<h4>Лицензия MIT</h4>
Смотрите файл <a href="https://github.com/loredanacirstea/svg.connectable.js/blob/master/LICENSE" target="_blank" onclick='no_js(event)'>лицензии</a>.</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-declarative-js/" target="_blank" id="3">svg.declarative.js</a></tt>
<div class=indent1><a href="https://github.com/saivan/svg.declarative.js" target="_blank">svg.declartive.js</a> a plugin for SVG.js which allows for super fast, interruptible, declarative animations. All animations are physically driven, so you can get very realistic animations with this library; whilst animating a huge number of items.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>

    Fast declarative animations for svg.js.

This plugin for SVG.js allows the user to specify only how they want their page to "look" and how long it should take to reach that state. The declarative api is in control of getting you there entirely, which is useful for a number of reasons:

&nbsp; &#9679; &nbsp; Цель может быть изменена посреди анимации и анимация будет подсчитывать как там оказаться.
The target can be changed mid-animation and the animation will figure out how to get there<br>
&nbsp; &#9679; &nbsp; Анимация управляется при помощи реальной физики, так что больше нет подделок, The animations are controlled using actual physics, so no more fake looking springs!<br>
&nbsp; &#9679; &nbsp; Можно иметь довольно много одновременно работающих анимаций.<br>

Посмотрите несколько демонстрационных примеров:<br>
&nbsp; &#9679; &nbsp; <a href="https://codepen.io/saivan/pen/zpdwpY" target="_blank" onclick='no_js(event)'>Simple Mouse follower</a><br>
&nbsp; &#9679; &nbsp; <a href="https://codepen.io/saivan/pen/xpXymb" target="_blank" onclick='no_js(event)'>Many body Mouse follower</a><br>
&nbsp; &#9679; &nbsp; <a href="https://codepen.io/saivan/pen/vpJmQJ" target="_blank" onclick='no_js(event)'>Vector field Explorer</a><br>
&nbsp; &#9679; &nbsp; <a href="https://codepen.io/saivan/pen/ZvrpYz" target="_blank" onclick='no_js(event)'>Покажи где я кликнул (Show me where I Clicked)</a><br>

<h3>Использование</h3>
Для использования данной библиотеки просто включите файл SVG.js в папку дистрибутива своего сайта и запустите его после включения svg.js.
API-интерфейс довольно прост и очень похож на местный API анимации. Чтобы сделать элемент декларативным, просто вызовите:
To use this library, just include the SVG.js file in the distribute folder for your site and run it after you've included svg.js. The api is quite straightforward and very similar to the native animate api. To make an element declarative just call:

<pre>element.declarative(&#60;controller&#62;)</pre>
Будет возвращен объект SVG.declarative, для которого можно напрямую редактировать цели.
This will return an SVG.declarative object that you can edit the targets for directly. The controller is just a function that you provide with the signature:

<pre>function (error, velocity, acceleration, integral) {
    // Do what you need (здесь делай что нужно)
    return [newPosition, newVelocity, newAcceleration]
}</pre>

Where:<br>
&nbsp; &#9679; &nbsp; <tt>error</tt> is the current difference between the intended value and the required value<br>
&nbsp; &#9679; &nbsp; <tt>velocity</tt> is the current amount the error is expected to change over the next second<br>
&nbsp; &#9679; &nbsp; <tt>acceleration</tt> is the current amount the velocity is expected to change over the next second<br>
&nbsp; &#9679; &nbsp; <tt>integral</tt> is the approximate integral of the error over the last second<br>

This is a powerful abstraction, but you won't need to define your own controller because we provide you with some of our own hand picked controllers that work really nicely.

    Our controllers can be found in SVG.controllers

A simple example is the damped spring, which simulates a bouncy spring:

<pre>SVG.controllers.spring({
    overShoot: 15,   // The percentage you want the object to shoot past the target before coming back
                     // The percentage you want the object to shoot past the target before coming back
    settleTime: 500, // The number of miliseconds before the object should settle
                     // The number of miliseconds before the object should settle
})</pre>

By default, we use this spring as our controller, but you can redefine it or even use another spring. You will probably find these animations surprisingly pleasant 😄

<h3>Manipulating Declaratives</h3>

You can manipulate declaratives by using any of the following methods:<br><br>

<code><span class="lnk" onmouseover="show('element pause - пауза (для) элемента')" onmouseout="hide()">element.pause</span>(<span class="lnk" onmouseover="show('state - состояние')" onmouseout="hide()">state</span>)</code><br>
Делает паузу в анимации, работающей в настоящее время. Если значением <tt>state</tt> является <tt>true</tt> анимация приостанавливается, если <tt>false</tt> работа анимации возобновляется.
Pauses the currently running animation. If state is true, we force pause, and if false we unpause.<br><br>

<code>element.continue()</code><br>

Continues the animation if it already converged (you probably won't need this yourself).<br><br>

<code>element.speed(newspeed)</code><br>
Устанавливает скорость анимации.<br><br>

<code>element.delay(time)</code><br>

Sets a delay before activating a new target. This can be useful to sequence animations.<br><br>

<code>element.override(should)</code><br>

If should is true, we always take the last target and ignore all other targets, so if you rapidly set two targets with different delays, we will just take the last one. This happens on a per attribute basis.<br><br>

<code>element.step(time)</code><br>

Advances the animation to the time specified. This is also usually called internally any time you change a target, so you probably won't need to use it yourself.<br><br>

<code>element.controller(newController)</code><br>

Allows you to pass in another function to act as the new controller from this point forward.<br><br>

<code>element.affine(useAffine)</code><br>

If useAffine is true, we attempt to preserve lengths while animating. Otherwise, we will directly morph one transformation into another, which is preferable in some circumstances.<br><br>

<code>element.around(cx, cy)</code><br>

If we are using affine transformations, we can set a transformation origin. This will guarantee that the transformations happen around a given origin to avoid any weird warping.<br><br>

Another cool addition is that you can use strings like top left, Top-Right, Bottom or middle and these should automatically set the transform origin around the corresponding point on the bounding box.<br><br>

<code>element.threshold(amount)</code><br>

If the change in all controllers is below the amount you specify, the simulation has converged, and we stop stepping to avoid animating forever.<br><br>

<h4>Постановка целей Setting Targets</h4>
Можно устанавливать цели
We can set the targets as we would with animate, we have the same basic functions available with the same api, including:<br>

&nbsp; &#9679; &nbsp; <tt>x</tt>, <tt>y</tt>, <tt>move</tt><br>
&nbsp; &#9679; &nbsp; <tt>cx</tt>, <tt>cy</tt>, <tt>center</tt><br>
&nbsp; &#9679; &nbsp; <tt>matrix</tt>, <tt>rotate</tt>, <tt>translate</tt>, <tt>scale</tt>, <tt>flip</tt>, <tt>skew</tt><br>
Также имеется <tt>position</tt>, которая всегда поместит центр в предоставленное положение.
We also have position, which will always put your center at the center postion provided.

<h3>Local Setup</h3>

To set this up, after cloning just run:
<pre>npm install</pre>

from the base folder

<h4>Running Examples</h4>

The examples found in the examples folder can be run with:

<pre>npm run demo &#60;folder-name&#62;</pre>

Where folder name is the folder containing the demo you want to run. This will run a webpack dev server which usually runs at port 8080 of your localhost, but it will print the correct port upon startup.

<h4>Building the Source</h4>

Just run the build script and it will take care of building everything:

<pre>npm run build</pre>
Если получились какие-либо ошибки, исправьте их и попробуйте снова!</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-draggable-js/" target="_blank" id="4">svg.draggable.js</a></tt>
<div class=indent1>Плагин <a href="https://github.com/svgdotjs/svg.draggable.js" target="_blank">svg.draggable.js</a> делает svg-элементы перетаскиваемыми.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Плагин для библиотеки <b>svg.js</b> чтобы сделать элементы перетаскиваемыми.<br>
svg.draggable.js лицензирован по условиям лицензии MIT.
<h3>Использование</h3>
Установите плагин:
<pre>npm install @svgdotjs/svg.draggable.js</pre>
Подключите его в своем html-документе, после подключения библиотеки svg.js.
<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.draggable.js"&#62;&#60;/script&#62;</pre>
Или для <a href="https://www.npmjs.com/package/esm" target="_blank" onmouseover="show('Исключительно простой, не требующий больших затрат,<br>загрузчик модулей ECMAScript.')" onmouseout="hide()">esm</a> просто запросите следующее:
<pre>import '@svgdotjs/svg.draggable.js'</pre>
Чтобы сделать svg-элемент перетаскиваемым, просто вызовите <tt>draggable()</tt> на этот элемент:
<pre>var draw = SVG().addTo('#canvas').size(400, 400)
var rect = draw.rect(100, 100)<br>
rect.draggable()</pre>
... И это на самом деле все! Теперь прямоугольник перетаскивается.<br><br>

<h4>События</h4>
Данный плагин запускает четыре разных события:<br>
&nbsp; &#9679; &nbsp; перед перетаскиванием - beforedrag (имеется возможность отмены)<br>
&nbsp; &#9679; &nbsp; начало перетаскивания - dragstart<br>
&nbsp; &#9679; &nbsp; процесс перетаскивания - dragmove (имеется возможность отмены)<br>
&nbsp; &#9679; &nbsp; окончание перетаскивания - dragend<br>
К этим событиям можно присоединять/отсоединять (bind/unbind) слушателей:
<pre>// bind (присоединение)
rect.on('dragstart.namespace', function (event) {
  // event.detail.event hold the given data explained below
  // event.detail.event удерживает заданные данные описанные ниже
  // this == rect
})<br>
// unbind (отсоединение)
rect.off('dragstart.namespace')</pre>

<h5>Детали события (event.detail)</h5>
События <tt>beforedrag</tt>, <tt>dragstart</tt>, <tt>dragmove</tt> и <tt>dragend</tt> предоставляют действие мышки/тачпада и обработчик, рассчитывающий перетаскивание.
Все события, кроме <tt>beforedrag</tt>, также предоставляют <tt>detail.box</tt>, который хранит начальный или новый <tt><span class="lnk" onmouseover="show('от англ. слов bounding box - ограничительная рамка')" onmouseout="hide()">bbox</span></tt> элемента перед или после перетаскивания.<br>
Данное свойство можно использовать для реализации настраиваемого поведения перетаскивания как показано ниже.<br>
Обратите внимание, что ограничительная рамка - это не то, что ожидается от вложенных svg-элементов,
так как они рассчитывают свои ограничительные рамки по своему содержимому, а не по значениям <tt>x</tt>, <tt>y</tt>, <tt>width</tt> и <tt>height</tt>.

Please note that the bounding box is not what you would expect for nested svgs because those calculate their bbox based on their content and not their x, y, width and height values. Therefore stuff like constraints needs to be implemented a bit differently.

<h5>Отменяемые события</h5>
Можно предотвратить действие по умолчанию событий <tt>beforedrag</tt> и <tt>dragmove</tt> с помощью вызова метода <tt>event.preventDefault()</tt> в функции обратного вызова. В этом случае фигура не будет перетаскиваться. Это пригодится, если потребуется реализовать свое собственное управление перетаскиванием.

<pre>rect.draggable().on('beforedrag', (e) => {
  e.preventDefault()
  // no other events are bound (никаких других событий не присоединено)
  // drag was completely prevented (перетаскивание было полностью предотвращено)
})<br>
rect.draggable().on('dragmove', (e) => {
  e.preventDefault()
  e.detail.handler.move(100, 200)
  // events are still bound e.g. dragend will fire anyway
  // события остаются присоединенными, например, в любом
  // случае сработает dragend - окончание перетаскивания
})</pre>

<h4>Настраиваемое поведение перетаскивания</h4>
<h5>Ограничения (constraints)</h5>
<pre>// Some constraints (x, y, width, height)
// Некоторые ограничения (<span class="lnk" onmouseover="show('координата по оси x')" onmouseout="hide()">x</span>, <span class="lnk" onmouseover="show('координата по оси y')" onmouseout="hide()">y</span>, <span class="lnk" onmouseover="show('width - ширина')" onmouseout="hide()">width</span>, <span class="lnk" onmouseover="show('height - высота')" onmouseout="hide()">height</span>)
const constraints = new SVG.Box(100, 100, 400, 400)<br>
rect.on('dragmove.namespace', (e) => {
  const {handler, box} = e.detail
  e.preventDefault()<br>
  let {x, y} = box<br>
  // In case your dragged element is a nested element,
  // you are better off using the rbox() instead of bbox()
  // В случае, если перетаскиваемый элемент является
  // вложенным, лучше вместо bbox() использовать rbox()<br>
  if (x &#60; constraints.x) {
    x = constraints.x
  }<br>
  if (y &#60; constraints.y) {
    y = constraints.y
  }<br>
  if (box.x2 > constraints.x2) {
    x = constraints.x2 - box.w
  }<br>
  if (box.y2 > constraints.y2) {
    y = constraints.y2 - box.h
  }<br>
  handler.move(x - (x%50), y - (y%50))
})</pre>
Привязка к сетке
<pre>rect.on('dragmove.namespace', (e) => {
  const {handler, box} = e.detail
  e.preventDefault()<br>
  handler.move(box.x - box.x % 50, box.y - box.y % 50)
})</pre>

<h4>Удаление</h4>
Функцию перетаскивания можно удалить, повторно вызвав функцию перетаскивания, используя в качестве аргумента значение <tt>false</tt>:
<pre>rect.draggable(false)</pre>

<h4>Ограничения</h4>
Если корневой svg-документ преобразован, данный плагин не будет работать в Firefox должным образом. Тем не менее на область просмотра он не повлияет.
If your root-svg is transformed this plugin won't work properly in Firefox. Viewbox however is not affected.

<h4>Зависимости</h4>
Данный модуль требует версию svg.js более или равной 3.0.10.</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-draw-js/" target="_blank" id="5">svg.draw.js</a></tt>
<div class=indent1>Плагин <a href="https://github.com/svgdotjs/svg.draw.js" target="_blank">svg.draw.js</a> для рисования элементов при помощи мышки.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Расширение svg.js, позволяющее рисовать элементы при помощи мышки.<br>
Демонстрацию можно увидеть на <a href="https://svgjs.com/svg.draw.js/demo/index.html" target="_blank" onclick='no_js(event)'>этой странице</a>.

<h4>Начало работы</h4>

    Install svg.draw.js using bower:
<pre>bower install svg.draw.js</pre>

    Include the script after svg.js into your page

<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.draw.js"&#62;&#60;/script&#62;</pre>

    Draw your first rectangle using this simple piece of code:

<pre>&#60;div id="myDrawing"&#62;&#60;/div&#62;<br>
var drawing = new SVG('myDrawing').size(500, 500);
drawing.rect().draw()	// Here we init a rectangle and start drawing it</pre>

<h4>Использование</h4>
По умолчанию рисование начинается с клика по svg-элементу
<pre>var drawing = SVG('drawing');
drawing.rect().draw(options);</pre>
Можно использовать свои собственные события мышки. Просто передавайте событие объекта в функцию рисования
You can use your own mouse-events. Just pass the event-Object to the draw-Function

<pre>var drawing = SVG('myDrawing');
var rect = drawing.rect();

drawing.on('mousedown', function(event){
    rect.draw(event, options);
});
drawing.on('mouseup', function(event){
    rect.draw(event);
});</pre>

The addon automatically knows when to start or stop drawing (most shapes start with the first event and stop with the second). However when dealing with e.g. a polygon you are able to set new points with every event. To finish the drawing you have to call the done-function. See the next chapter for that.

<h4>Методы</h4>

svg.draw.js populates its methods it uses to draw the shape. This is useful in edgecases but generally not needed. However the method done is needed for poly-shapes and cancel can be called on every shape to stop drawing and remove the shape.

<pre>// Finishes the poly-shape
polygon.draw('done');

// Cancels drawing of a shape, removes it
polygon.draw('cancel');

/* The following are only useful in edge-cases */

// Draws a new point with the help of (mouse-)event
polygon.draw('point', event)

// Draws the point while moving the mouse (basically the animation)
polygon.draw('update', evnt)

// Stop drawing, cleans up
polygon.draw('stop', event)</pre>

<h4>Опции</h4>
Следующие опции можно использовать для изменения поведения данного дополнения:
The following options can be used to modify the behavior of the addon:<br>

&nbsp; &#9679; &nbsp; <code>snapToGrid</code>: Определяет сетку, по которой выравнивается точка (значением по умолчанию является&nbsp;<tt>1</tt>). Specifies a grid to which a point is aligned (default:1)<br>

Note that you can specify the options only on the first call. When you want to change the options while drawing use polygon.draw('params', key, value) This is useful when you want to activate the grid-option when ctrl or soemthing is pressed.

<h4>События</h4>
svg.draw.js запускает несколько конкретных событий:<br>
&nbsp; &#9679; &nbsp; <span class="lnk" onmouseover="show('draw start - начало рисования')" onmouseout="hide()">drawstart</span><br>
&nbsp; &#9679; &nbsp; <span class="lnk" onmouseover="show('draw stop - остановка рисования')" onmouseout="hide()">drawstop</span><br>
&nbsp; &#9679; &nbsp; <span class="lnk" onmouseover="show('draw update - обновление рисования')" onmouseout="hide()">drawupdate</span><br>
&nbsp; &#9679; &nbsp; <span class="lnk" onmouseover="show('draw point - точка рисования')" onmouseout="hide()">drawpoint</span><br>
&nbsp; &#9679; &nbsp; <span class="lnk" onmouseover="show('draw done - рисование сделано')" onmouseout="hide()">drawdone</span><br>
&nbsp; &#9679; &nbsp; <span class="lnk" onmouseover="show('draw cancel - отмена рисования')" onmouseout="hide()">drawcancel</span><br>
Эти события вызываются в конце соответствующего метода.
These events are called at the end of the corresponding method.<br>
Каждый объект-событие сохраняет позицию относительно объекта-родителя фигуры (которым является в основном сам SVG-документ) в виде массива.
Each event-object holds the relative position to the parent-Object of the Shape (which is mostly the SVG-doc itself) as Array<br>
Привязать функцию к событию просто:
Binding a function to the Event is easy

<pre>var draw = SVG('drawing');
var rect = draw.rect().draw();
rect.on('drawstart', function(event){
    console.log(event.detail); // Holds event, current Point-coords and matrix
                               // Содержит событие, текущие координаты точки и матрицу
});</pre>

<h4>Плагины</h4>
На настоящий момент svg.draw.js поддерживает только основные фигуры (линия, ломаная линия, многоугольник, прямоугольник, изображение, круг, эллипс).
Все остальные типы, которые нужно нарисовать и которые доступны через SVG.invent (например, изображение или свой собственный элемент), можно добавить с помощью плагина, который просто выполняет функции рисования фигуры.
Currently svg.draw.js only supports all the basic shapes (line, polyline, polygone, rect, image, circle, ellipse). Any other type you want to draw and is available through SVG.invent (e.g. image or your own element) can be added using a plugin which just serves the functions to draw the shape.<br>
Например:
<pre>SVG.Element.prototype.draw.extend('line polyline polygon', {

	// add methods here which should be added to the draw-object
	// e.g.
	foo: function(){
		// can access this
	}

	// or even variables
	bar:5

}</pre>

Method calc is always needed which updates the point of the shape.

You also can extend two shape-types at once:

<pre>SVG.Element.prototype.draw.extend({

	'line polyline polygon': {
		// add methods here which should be added to the draw-object
		// e.g.
		foo: function(){
			// can access this
		}

		// or even variables (или даже переменные)
		bar:5
	}


	'circle':{
		// something (что-нибудь)
	}
}</pre>
Смотрите реализацию всех фигур в виде <a href="https://svgjs.com/svg.draw.js/demo/index.html" target="_blank" onclick='no_js(event)'>примеров</a>.</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-easing-js/" target="_blank" id="6">svg.easing.js</a></tt>
<div class=indent1><a href="https://github.com/svgdotjs/svg.easing.js" target="_blank">svg.easing.js</a> for more easing methods on animations.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Additional easing equations for the fx module in the svg.js library.<br>

Svg.easing.js is licensed under the terms of the MIT License.

<h4>Использование</h4>
Подключите данный плагин в своем html-документе после включения в него библиотеки svg.js.<br>

To use the custom easing methods:
<pre>var draw = SVG('paper').size(400, 400)
var rect = draw.rect(100, 100)<br>
rect.animate(500, 'bounce').move(300, 300)</pre>

Available easing methods are:<br>
&nbsp; &#9679; &nbsp; quadIn<br>
&nbsp; &#9679; &nbsp; quadOut<br>
&nbsp; &#9679; &nbsp; quadInOut<br>
&nbsp; &#9679; &nbsp; cubicIn<br>
&nbsp; &#9679; &nbsp; cubicOut<br>
&nbsp; &#9679; &nbsp; cubicInOut<br>
&nbsp; &#9679; &nbsp; quartIn<br>
&nbsp; &#9679; &nbsp; quartOut<br>
&nbsp; &#9679; &nbsp; quartInOut<br>
&nbsp; &#9679; &nbsp; quintIn<br>
&nbsp; &#9679; &nbsp; quintOut<br>
&nbsp; &#9679; &nbsp; quintInOut<br>
&nbsp; &#9679; &nbsp; sineIn<br>
&nbsp; &#9679; &nbsp; sineOut<br>
&nbsp; &#9679; &nbsp; sineInOut<br>
&nbsp; &#9679; &nbsp; expoIn<br>
&nbsp; &#9679; &nbsp; expoOut<br>
&nbsp; &#9679; &nbsp; expoInOut<br>
&nbsp; &#9679; &nbsp; circIn<br>
&nbsp; &#9679; &nbsp; circOut<br>
&nbsp; &#9679; &nbsp; circInOut<br>
&nbsp; &#9679; &nbsp; backIn<br>
&nbsp; &#9679; &nbsp; backOut<br>
&nbsp; &#9679; &nbsp; backInOut<br>
&nbsp; &#9679; &nbsp; swingFromTo<br>
&nbsp; &#9679; &nbsp; swingFrom<br>
&nbsp; &#9679; &nbsp; swingTo<br>
&nbsp; &#9679; &nbsp; bounce<br>
&nbsp; &#9679; &nbsp; bounceOut<br>
&nbsp; &#9679; &nbsp; elastic<br>
</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-filter-js/" target="_blank" id="7">svg.filter.js</a></tt>
<div class=indent1>Плагин <a href="https://github.com/svgdotjs/svg.filter.js" target="_blank">svg.filter.js</a> добавляет к элементам svg-фильтры.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Плагин для библиотеки SVG.js, который добавляет функции фильтров.<br>
Плагин svg.filter.js лицензируется в соответствии с условиями лицензии MIT.<br>

    Examples
    Furthermore
        unfilter
        referencing the filter node
        Animating filter values
        Chaining Effects
    Effect Classes

<h3>Использование</h3>
Npm
<pre>npm i @svgdotjs/svg.filter.js</pre>
Yarn
<pre>yarn add @svgdotjs/svg.filter.js</pre>
Подключите данный плагин в html-документ после подключения библиотеки svg.js.
<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.filter.js"&#62;&#60;/script&#62;</pre>

Here is how each filter effect on the example page is achieved.

<h4>Примеры</h4>

    gaussian blur
    horizontal blur
    desaturate
    contrast
    sepiatone
    hue rotate 180
    luminance to alpha
    colorize
    posterize
    darken
    lighten
    invert
    gamma correct 1
    gamma correct 2
    drop shadow
    extrude

<h5>original</h5>
<pre>var image = draw.image('path/to/image.jpg').size(300, 300)</pre>

<h5>gaussian blur</h5>
<pre>image.filterWith(function(add) {
  add.gaussianBlur(30)
})</pre>

<h5>horizontal blur</h5>
<pre>image.filterWith(function(add) {
  add.gaussianBlur(30, 0)
})</pre>

<h5>desaturate</h5>
<pre>image.filterWith(function(add) {
  add.colorMatrix('saturate', 0)
})</pre>

<h5>contrast</h5>
<pre>image.filterWith(function(add) {
  var amount = 1.5

  add.componentTransfer({
    type: 'linear',
    slope: amount,
    intercept: -(0.3 * amount) + 0.3
  })
})</pre>

<h5>sepiatone</h5>
<pre>image.filterWith(function(add) {
  add.colorMatrix('matrix', [ .343, .669, .119, 0, 0
                            , .249, .626, .130, 0, 0
                            , .172, .334, .111, 0, 0
                            , .000, .000, .000, 1, 0 ])
})</pre>

<h5>hue rotate 180</h5>
<pre>image.filterWith(function(add) {
  add.colorMatrix('hueRotate', 180)
})</pre>

<h5>luminance to alpha</h5>
<pre>image.filterWith(function(add) {
  add.colorMatrix('luminanceToAlpha')
})</pre>

<h5>colorize</h5>
<pre>image.filterWith(function(add) {
  add.colorMatrix('matrix', [ 1.0, 0,   0,   0,   0
                            , 0,   0.2, 0,   0,   0
                            , 0,   0,   0.2, 0,   0
                            , 0,   0,   0,   1.0, 0 ])
})</pre>

<h5>posterize</h5>
<pre>image.filterWith(function(add) {
  add.componentTransfer({
    type: 'discrete',
    tableValues: [0, 0.2, 0.4, 0.6, 0.8, 1]
  })
})</pre>

<h5>darken</h5>
<pre>image.filterWith(function(add) {
  add.componentTransfer({
    type: 'linear',
    slope: 0.2
  })
})</pre>

<h5>lighten</h5>
<pre>image.filterWith(function(add) {
  add.componentTransfer({
    type: 'linear',
    slope: 1.5,
    intercept: 0.2
  })
})</pre>

<h5>invert</h5>
<pre>image.filterWith(function(add) {
  add.componentTransfer({
    type: 'table'
    tableValues: [1, 0]
  })
})</pre>

<h5>gamma correct 1</h5>
<pre>image.filterWith(function(add) {
  add.componentTransfer({
    g: { type: 'gamma', amplitude: 1, exponent: 0.5 }
  })
})</pre>

<h5>gamma correct 2</h5>
<pre>image.filterWith(function(add) {
  add.componentTransfer({
    g: { type: 'gamma', amplitude: 1, exponent: 0.5, offset: -0.1 }
  })
})</pre>

<h5>drop shadow</h5>

You will notice that all the effect descriptions have a drop shadow. Here is how this drop shadow can be achieved:
<pre>var text = draw.text('SVG text with drop shadow').fill('#fff')

text.filter(function(add) {
  var blur = add.offset(0, 1).in(add.$sourceAlpha).gaussianBlur(1)

  add.blend(add.$source, blur)
})</pre>

This technique can be achieved on any other shape of course:
<pre>var rect = draw.rect(100,100).fill('#f09').stroke({ width: 3, color: '#0f9' }).move(10,10)

rect.filter(function(add) {
  var blur = add.offset(20, 20).in(add.$sourceAlpha).gaussianBlur(5)

  add.blend(add.$source, blur)

  this.size('200%','200%').move('-50%', '-50%')
})</pre>

If the drop shadow should get the colour of the shape so it appears like coloured glass:
<pre>var rect = draw.rect(100,100).fill('#f09').stroke({ width: 3, color: '#0f9' }).move(10,10)

rect.filter(function(add) {
  var blur = add.offset(20, 20).gaussianBlur(5)

  add.blend(add.$source, blur)

  this.size('200%','200%').move('-50%', '-50%')
})</pre>

<h5>extrude</h5>
<pre>image.filterWith(function(add){
  var matrix = add.convolveMatrix([
    1,0,0,0,0,0,
    0,1,0,0,0,0,
    0,0,1,0,0,0,
    0,0,0,1,0,0,
    0,0,0,0,1,0,
    0,0,0,0,0,1
  ]).attr({
    devisor: '2',
    preserveAlpha: 'false'
  }).in(add.$sourceAlpha)

  //recolor it
  var color = add.composite(add.flood('#ff2222'),matrix,'in');

  //merge all of them toggether
  add.merge(color,add.$source);
})</pre>

<h4>Furthermore</h4>

Some more features you should know about.
<h5>unfilter</h5>

The unfilter method removes the filter attribute from the node:
<pre>image.unfilter()</pre>

<h5>creating a reusable filter</h5>

its also posible to create a filter by using the new keyword NOTE: when creating a filter this way, it can take an optional attr object
<pre>var filter = new SVG.Filter();

// create the filters effects here
filter.offset(20, 20).gaussianBlur(5);
filter.blend(filter.$source, blur);
filter.size('200%','200%').move('-50%', '-50%')</pre>

then once you have created the filter you can use it one multiple elements
<pre>var image = new SVG.Image();
var shape = new SVG.Rect(10, 10);

image.filterWith(filter);
shape.filterWith(filter);</pre>

<h5>referencing the filter node</h5>

An internal reference to the filter node is made in the element:
<pre>image.filterer()</pre>

This can also be very useful to reuse an existing filter on various elements:
<pre>otherimage.filterWith(image.filterer())</pre>

<h5>Animating filter values</h5>

Every filter value can be animated as well:
<pre>var hueRotate

image.filterWith(function(add) {
  hueRotate = add.colorMatrix('hueRotate', 0)
})

hueRotate.animate(3000).attr('values', 360)</pre>

<h5>Chaining Effects</h5>

Method chaining is a programing style where each function returns the object it belongs to, for an example look at JQuery.
it's possible to chain the effects on a filter when you are creating them, for example:
<pre>image.filterWith(function(add){
  add.flood('black',0.5).composite(add.$sourceAlpha,'in').offset(10).merge(add.$source)
})</pre>

this would create a basic shadow filter where the first input on the composite effect would be the flood effect, and the input on the offset effect would be the composite effect.
same with the merge effect, its first input would be the offset effect, and its second input would be add.$source

some effects like Merge, Blend, Composite, DisplacementMap have thier arguments changed when they are chained, for example
<pre>image.filterWith(function(add){
  add.flood('black',0.5).composite(add.$sourceAlpha,'in')
})</pre>

the composite effects first input is set to the flood effect and its second input becomes the first argument, this is the same for the merge, blend, composite, and displacmentMap effect.
for more details check out each effects doc below

<h3>Effect Classes</h3>

    Base Effect Class
    Blend
    ColorMatrix
    ComponentTransfer
    Composite
    ConvolveMatrix
    DiffuseLighting
    DisplacementMap
    Flood
    GaussianBlur
    Image
    Merge
    Morphology
    Offset
    SpecularLighting
    Tile
    Turbulence

<h4>Base Effect Class</h4>
in(effect)

gets or sets the in attribute of the effect

    effect: this can be another effect or a string
    if effect is not provided it will look for another effect on the same filter whose result is equal to this effects in attribute, else it will return the value of the in attribute
<pre>image.filterWith(function(add){
  var offset = add.offset(10)

  //create the blur effect and then set its input
  var blur = add.gaussianBlur(3)

  //set the input to an effect
  blur.in(offset)

  //this will return the offset effect
  var input = blur.in()

  //set the input to a string
  blur.in('another-result-as-a-string')

  //this will return a string since there is no other effect which has a matching result attribute
  var input2 = blur.in()
})</pre>

in2(effect)

gets or sets the in2 attribute of the effect
this function works the same as the in method.
it's only on effects (Blend, Composite, and DisplacementMap)
result(string)

gets or sets the result attribute of the effect

    string: if a string is provided it will set the value of the result attribute.
    if no arguments are provided it will act as a getter and return the value of the result attribute

Blend

W3 doc

filter.blend(in1, in2, mode)
//or
new SVG.BlendEffect({in1, in2, mode})

    in1: an effect or the result of effect
    in2: same as in1
    mode: "normal | multiply | screen | darken | lighten" defaults to "normal"

chaining when this effect is called right after another effect, for example:

filter.offset(10).blend(filter.$source)

the first input is set to the offset effect and the second input is set to filter.$source or what ever was passed as the first argument, and the second input becomes the mode
ColorMatrix

W3 doc

filter.colorMatrix(type, values);
//or
new SVG.ColorMatrixEffect({type, values});

    type: "matrix | saturate | hueRotate | luminanceToAlpha"
    values
        type="matrix": values would be a matrix the size of 4x5
        type="saturate": number (0 to 1)
        type="hueRotate": number (0 to 360) deg
        type="luminanceToAlpha": value not needed

ComponentTransfer

W3 doc

filter.componentTransfer(components);
// or
filter.componentTransfer(function (add) { add.funcA({ type... }) });
//or
new SVG.ComponentTransferEffect();

    components: an object which is set for all chanels or r, g, b, a properties for each chanel

      type: "identity | table | discrete | linear | gamma",

      //type="table"
      tableValues: "0 0.5 2 1", //number separated by spaces

      //type="linear"
      slope: 1, //number
      intercept: 3,//number

      //type="gamma"
      amplitude: 0, //number
      exponent: 0, //number
      offset: 0 //number
    }

Composite

W3 doc

filter.composite(in1, in2, operator);
//or
new SVG.CompositeEffect({in1, in2, operator});

    in1: an effect or the result of an effect
    in2: same as in1
    operator: "over | in | out | atop | xor | arithmetic" defaults to "over"

chaining when this effect is called right after another effect, for example:

filter.flood('black',0.5).composite(filter.$sourceAlpha,'in')

the first input is set to the flood effect and the second input is set to filter.$sourceAlpha or what ever was passed as the first argument.
also the second argument becomes the operator
ConvolveMatrix

W3 doc

filter.convolveMatrix(matrix);
//or
new SVG.ConvolveMatrixEffect({matrix});

    matrix: a square matrix of numbers that will be applied to the image
        exmaple:

    [
      1,0,0,
      0,1,0,
      0,0,1
    ]

DiffuseLighting

W3 doc

filter.diffuseLighting(surfaceScale, lightingColor, diffuseConstant, kernelUnitLength);
//or
new SVG.DiffuseLightingEffect({surfaceScale, lightingColor, diffuseConstant, kernelUnitLength});

very complicated, just check out the W3 doc
DisplacementMap

W3 doc

filter.displacementMap(in1, in2, scale, xChannelSelector, yChannelSelector);
//or
new SVG.DisplacementMapEffect({in1, in2, scale, xChannelSelector, yChannelSelector});

very complicated, just check out the W3 doc

chaining when this effect is called right after another effect, for example:

filter.offset(20,50).displacementMap(filter.$source,2)

the first input is set to the offset effect and the second input is set to filter.$source or what ever was passed as the first argument.
also the second argument becomes the scale, and the third argument is the xChannelSelector and so on
Flood

W3 doc

filter.flood(color,opacity);
//or
new SVG.FloodEffect(color,opacity);

    color: a named or hex color in string format
    opacity: number form 0 to 1

GaussianBlur

W3 doc

filter.gaussianBlur(x, y);
//or
new SVG.GaussianBlurEffect({x, y});

    x: blur on the X
    y: blur on the y, will default to the x if not provided

Image

W3 doc

filter.image(src);
//or
new SVG.ImageEffect({src});

Merge

W3 doc

filter.merge();
//or
new SVG.MergeEffect();

    Array: an Array of effects or effect results filter.merge([effectOne,"result-two",another_effect])
    chaining you can also chain the merge effect filter.offset(10).merge(anotherEffect) which will result in a merge effect with its first input set to the offset effect and its second input set to anotherEffect

Morphology

W3 doc

filter.morphology(operator, radius);
//or
new SVG.MorphologyEffect({operator, radius});

    operator: "erode | dilate"
    radius: a single number or a string of two numbers separated by a space
        the first number is the X
        the second number is the Y, if no second number was provided it will default to the first number

Offset

W3 doc

filter.offset(x, y);
//or
new SVG.OffsetEffect({x, y});

    x: move on the X
    y: move on the y, will default to the x if not provided

SpecularLighting

W3 doc

filter.specularLighting(surfaceScale, lightingColor, diffuseConstant, specularExponent, kernelUnitLength);
//or
new SVG.SpecularLightingEffect(surfaceScale, lightingColor, diffuseConstant, specularExponent, kernelUnitLength);

very complicated, just check out the W3 doc
Tile

W3 doc

filter.tile();
//or
new SVG.TileEffect();

no arguments, but if you want to find out what it does check out the W3 doc
Turbulence

W3 doc

filter.turbulence(baseFrequency, numOctaves, seed, stitchTiles, type);
//or
new SVG.TurbulenceEffect({baseFrequency, numOctaves, seed, stitchTiles, type});

very complicated, just check out the W3 doc</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-foreignobject-js/" target="_blank" id="8">svg.foreignobject.js</a></tt>
<div class=indent1><a href="https://github.com/john-memloom/svg.foreignobject.js" target="_blank">svg.foreignobject.js</a> foreignObject implementation (by john-memloom).</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Плагин для библиотеки SVG.js для создания в svg элементов внешних объектов. A plugin for the svg.jscom library to create foreign object elements in svg.
Подробнее об элементе foreignObject смотрите в <a href="http://www.w3.org/TR/SVG/extend.html#ForeignObjectElement" target="_blank" onclick='no_js(event)'>SVG-документации</a>.
See SVG Documentation on the foreignObject element for more details.
Плагин svg.foreignobject.js лицензируется в соответствии с условиями лицензии MIT.<br>

<h3>Использование</h3>
Подключите данный плагин в html-документ после подключения библиотеки svg.js.
<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.foreignobject.js"&#62;&#60;/script&#62;</pre>

To add a foreignobject

<pre>var canvas = SVG('canvas').size(1024, 550)
var fobj = canvas.foreignObject(100,100).attr({id: 'fobj'})</pre>

To add a child note

<pre>var txt = "some text that is quite long.  and it goes on and on.  and it's pointless really.  and the grammar is terrible.  blah. blah. blah"
fobj.appendChild("div", {id: 'mydiv', innerText: txt})</pre>

The first argument to appendChild is either a node or a string describing the type of element to create. The second argument is a list of attributes to set on the element.<br>

Note that the foreignObject element can be manipulated with the standard svg.js methods (move(), rotate(), scale() etc.), whereas the contained node can be manipulated separately. For example if you embed a HTML element you can use jQuery (or whaever you choose) to manipulate the embedded object.

<h3>Пример</h3>
Посмотрите представленный <a href="https://github.com/memloom-development/svg.foreignobject.js/blob/master/sample.html" target="_blank" onclick='no_js(event)'>sample.html</a>.
<h3>Зависимости</h3>
Этот плагин требует SVG.js v0.12.</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/plugins/svg-intersections-js/" target="_blank" id="9">svg.intersections.js</a></tt>
<div class=indent1>Плагин <a href="https://github.com/amatiash/svg.intersections.js" target="_blank">svg.intersections.js</a> для поиска точек пересечения путей и линий (от amatiash)</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Плагин для поиска пересечений путей и линий.<br>
<a href="https://amatiash.github.io/svg.intersections.js/demo.html" target="_blank" onclick='no_js(event)'>Демонстрационный пример</a>.<br>
Лицензируется в соответствии с условиями лицензии MIT.<br>

<h3>Установка</h3>
<pre>npm i -S svg.intersections.js</pre>

For non- AMD or CommonJS adds a global SVGIntersections.

<h3>Использование</h3>
<pre>var draw = SVG('drawing').size(400, 400),
    line  = draw.line(19, 127, 252, 386).stroke('blueviolet'),
    path  = draw.path('M140 45 L 12 250').stroke('darkorange'),
    intersectionPoints;</pre>
Далее
<pre>intersectionPoints = path.intersectsLine(line);</pre>
Или
<pre>intersectionPoints = line.intersectsPath(path);</pre>
Результат
<pre>[
    {
        x: 62.453914292554465,
        y: 175.3028489346421
    }
]</pre>
При проверке, путь сначала разбивается на отрезки линии и затем они проверяются на пересечение линии с линией.<br>
<tt>segmentLength</tt> определяет длину отрезка линии.<br>
Чем больше длина отрезка, тем быстрее проходит проверка, но снижается точность.<br>
Тщательная проверка пересечения двух путей (особенно длинных) с высокой точностью может быть на самом деле очень медленной.<br>

<h4>Доступные методы</h4>
<h5>SVG.Path</h5>
<pre>.intersectsLine(line [, segmentLength])</pre>
<pre>.intersectsPath(path [, segmentLength])</pre>
<h5>SVG.Line</h5>
<pre>.intersectsLine(line)</pre>
<pre>.intersectsPath(path [, segmentLength])</pre>

<h3>API</h3>
<h4>SVGIntersections</h4>

    SVGIntersections
        ~path_linePos(pathEl, linePos, [segmentLength]) ⇒ Array.&#60;Point&#62;
        ~linePos_linePos(line1Pos, line2Pos) ⇒ Point | undefined
        ~fromLineToLinePos(line) ⇒ Object
        ~lengthBetweenTwoPoints(x1, y1, x2, y2) ⇒ number
        ~isPointOnLine(x1, y1, x2, y2, x, y) ⇒ Point | undefined
        ~Position : Object
        ~Point : Object

SVGIntersections~path_linePos(pathEl, linePos, [segmentLength]) ⇒ Array.&#60;Point&#62;

Get intersection points for a path element and a line position. Devides a path into line segments and finds line-to-line intersection.

Kind: inner method of SVGIntersections
Returns: Array.&#60;Point&#62; - - Array of intersection points
<table class="tbl_1" border="1" cellpadding="5">
<tr class="head"><td>Параметр</td><td>Тип</td><td>Значение по<br>умолчанию</td><td>Описание</td></tr>
<tr valign="top"><td align="center"><tt>pathEl</tt></td><td>объект</td><td></td><td>элемент SVG.Path</td></tr>
<tr valign="top"><td align="center"><tt>linePos</tt></td><td>позиция</td><td></td><td>начальная и конечная позиция линии</td></tr>
<tr valign="top"><td align="center"><tt>[segmentLength]</tt></td><td>число</td><td align="center">10</td><td>Длина отрезка пути. Используется для точности.</td></tr></table><br>

SVGIntersections~linePos_linePos(line1Pos, line2Pos) ⇒ Point | undefined

Get intersection point for 2 lines depending on their start&end position points. Original function

Kind: inner method of SVGIntersections
Returns: Point | undefined - - Intersection point or undefined
<table class="tbl_1" border="1" cellpadding="5">
<tr class="head"><td>Параметр</td><td>Тип</td><td>Описание</td></tr>
<tr valign="top"><td align="center"><tt>line1Pos</tt></td><td>позиция</td><td>начальная и конечная позиции первой линии</td></tr>
<tr valign="top"><td align="center"><tt>line2Pos</tt></td><td>позиция</td><td>начальная и конечная позиции второй линии</td></tr></table><br>
SVGIntersections~fromLineToLinePos(line) ⇒ Object

Get start&end points from a line

Kind: inner method of SVGIntersections
Returns: Object - - Start&end points
<table class="tbl_1" border="1" cellpadding="5">
<tr class="head"><td>Параметр</td><td>Тип</td><td>Описание</td></tr>
<tr valign="top"><td align="center"><tt>line</tt></td><td>объект</td><td>элемент SVG.Line</td></tr></table><br>

SVGIntersections~lengthBetweenTwoPoints(x1, y1, x2, y2) ⇒ number

Find length between two points

Kind: inner method of SVGIntersections
Returns: number - - Length between start&end position
<table class="tbl_1" border="1" cellpadding="5">
<tr class="head"><td>Параметр</td><td>Тип</td><td>Описание</td></tr>
<tr valign="top"><td align="center"><tt>x1</tt></td><td>число</td><td>начальная точка x</td></tr>
<tr valign="top"><td align="center"><tt>y1</tt></td><td>число</td><td>начальная точка y</td></tr>
<tr valign="top"><td align="center"><tt>x2</tt></td><td>число</td><td>конечная точка x</td></tr>
<tr valign="top"><td align="center"><tt>y2</tt></td><td>число</td><td>конечная точка y</td></tr></table><br>

SVGIntersections~isPointOnLine(x1, y1, x2, y2, x, y) ⇒ Point | undefined

Check if point is on line

Kind: inner method of SVGIntersections
Returns: Point | undefined - - Check point or undefined
<table class="tbl_1" border="1" cellpadding="5">
<tr class="head"><td>Параметр</td><td>Тип</td><td>Описание</td></tr>
<tr valign="top"><td align="center"><tt>x1</tt></td><td>число</td><td>начальная точка x</td></tr>
<tr valign="top"><td align="center"><tt>y1</tt></td><td>число</td><td>начальная точка y</td></tr>
<tr valign="top"><td align="center"><tt>x2</tt></td><td>число</td><td>конечная точка x</td></tr>
<tr valign="top"><td align="center"><tt>y2</tt></td><td>число</td><td>конечная точка y</td></tr>
<tr valign="top"><td align="center"><tt>x</tt></td><td>число</td><td>контрольная точка x</td></tr>
<tr valign="top"><td align="center"><tt>y</tt></td><td>число</td><td>контрольная точка y</td></tr></table><br>

SVGIntersections~Position : Object

Kind: inner typedef of SVGIntersections
Properties
<table class="tbl_1" border="1" cellpadding="5">
<tr class="head"><td>Название</td><td>Тип</td><td>Описание</td></tr>
<tr valign="top"><td align="center"><tt>x1</tt></td><td>число</td><td>начальная точка x</td></tr>
<tr valign="top"><td align="center"><tt>y1</tt></td><td>число</td><td>начальная точка y</td></tr>
<tr valign="top"><td align="center"><tt>x2</tt></td><td>число</td><td>конечная точка x</td></tr>
<tr valign="top"><td align="center"><tt>y2</tt></td><td>число</td><td>конечная точка y</td></tr></table><br>

SVGIntersections~Point : Object

Kind: inner typedef of SVGIntersections
Properties
<table class="tbl_1" border="1" cellpadding="5">
<tr class="head"><td>Название</td><td>Тип</td></tr>
<tr valign="top"><td align="center"><tt>x</tt></td><td>число</td></tr>
<tr valign="top"><td align="center"><tt>y</tt></td><td>число</td></tr></table><br>
</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-math-js/" target="_blank" id="10">svg.math.js</a></tt>
<div class=indent1>Плагин <a href="https://github.com/otm/svg.math.js" target="_blank">svg.math.js</a> добавляет математические функции (от Nils Lagerkvist).</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Это плагин для библиотеки svg.js, который предоставляет общепринятые математические функции.<br>
svg.math.js лицензируется в соответствии с условиями лицензии MIT.<br>

<h3>Использование</h3>
Подключите данный плагин в html-документ после подключения svg.js.
<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.math.js"&#62;&#60;/script&#62;</pre>

<h3>Введение</h3>
Математическая библиотека предназначена для помощи в общепринятых геометрических вычислений при работе с SVG.js. Библиотека разделяется на отдельные функции и на точечный (point) и линейный (line) объекты.
Все углы в библиотеке измеряются в радианах (если не оговорено другое).<br><br>
<h4>Объект: SVG.math</h4>
<code><span class="lnk" onmouseover="show('angle - угол')" onmouseout="hide()">angle</span>(<span class="lnk" onmouseover="show('сокращ. англ. слова point - точка')" onmouseout="hide()">p1</span>, <span class="lnk" onmouseover="show('сокращ. англ. слова point - точка')" onmouseout="hide()">p2</span>[, <span class="lnk" onmouseover="show('сокращ. англ. слова point - точка')" onmouseout="hide()">p3</span>])</code><br>
Вычисляет угол между линией и горизонтальной осью координат, или угол между тремя точками.
<div class=list><h5>Синтаксис:</h5>
<pre>var angle = SVG.math.angle(p1, p2[, p3])</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>p1</tt> - <span class="shadow">(объект точка)</span> - первая точка<br>
&nbsp; 2. &nbsp; <tt>p2</tt> - <span class="shadow">(объект точка)</span> - вторая точка<br>
&nbsp; 3. &nbsp; <tt>p3</tt> - <span class="shadow">(объект точка)</span> - третья точка (дополнительный, необязательный аргумент)<br>

<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(число)</span> Числовое значение от&nbsp;<tt>0</tt> до&nbsp;<tt>2*pi</tt><br>
<img src="img/svg.math.js1.png" onmouseover="show('SVG.math.angle(p1, p2[, p3])')" onmouseout="hide()"></div><br><br>

<code><span class="lnk" onmouseover="show('rad - сокращ. англ. слова radian - радиан')" onmouseout="hide()">rad</span>(<span class="lnk" onmouseover="show('degree - градус')" onmouseout="hide()">degree</span>)</code><br>
Конвертирует угол в градусах в радианы.
<div class=list><h5>Синтаксис:</h5>
<pre>var angle = SVG.math.rad(degree)</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>degree</tt> - <span class="shadow">(число)</span> - угол в градусах<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(число)</span> - угол в радианах</div><br><br>

<code><span class="lnk" onmouseover="show('deg - сокращ. англ. слова degree - градус')" onmouseout="hide()">deg</span>(<span class="lnk" onmouseover="show('radians - радианы')" onmouseout="hide()">radians</span>)</code><br>
Конвертирует угол в радианах в градусы.
<div class=list><h5>Синтаксис:</h5>
<pre>var angle = SVG.math.deg(radians)</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>radians</tt> - <span class="shadow">(число)</span> - угол в радианах<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(число)</span> - угол в градусах</div><br><br>

<code><span class="lnk" onmouseover="show('snap to angle - привязать ко углу')" onmouseout="hide()">snapToAngle</span>(<span class="lnk" onmouseover="show('angle - угол')" onmouseout="hide()">angle</span>, <span class="lnk" onmouseover="show('directions - направления')" onmouseout="hide()">directions</span>)</code><br>
Округляет угол до ближайшего угла в массиве направлений.
<div class=list><h5>Синтаксис:</h5>
<pre>var angle = SVG.math.snapToAngle(angle, [0, Math.PI/2, Math.PI, Math.PI*3/2])</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>angle</tt> - <span class="shadow">(число)</span> угол в радианах<br>
&nbsp; 2. &nbsp; <tt>directions</tt> - <span class="shadow">(массив)</span> - массив, содержащий углы<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(число)</span> - угол в градусах</div><br><br>

<code><span class="lnk" onmouseover="show('lerp - сокращ. англ. слов linear interpolation - линейная интерполяция')" onmouseout="hide()">lerp</span>(<span class="lnk" onmouseover="show('a - буква латинского алфавита,<br>здесь обозначает одну из заданных точек')" onmouseout="hide()">a</span>, <span class="lnk" onmouseover="show('b - буква латинского алфавита,<br>здесь обозначает одну из заданных точек')" onmouseout="hide()">b</span>, <span class="lnk" onmouseover="show('x - буква латинского алфавита,<br>здесь обозначает коэффициент интерполяции')" onmouseout="hide()">x</span>)</code><br>
Выполняется <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%B0%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8F%D1%86%D0%B8%D1%8F" target="_blank" onclick='no_js(event)' onmouseover="show(' Интерполяция - это вычисление промежуточных<br>значений между набором известных точек.')" onmouseout="hide()">линейная интерполяция</a> между значениями аргументов&nbsp;<tt>a</tt> и&nbsp;<tt>b</tt>, где коэффициент интерполяции <tt>0&nbsp;&#60;=&nbsp;x&nbsp;&#60;=&nbsp;1</tt>.
<div class=list><h5>Синтаксис:</h5>
<pre>var angle = SVG.math.lerp(a, b, x)</pre>

<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>a</tt> - <span class="shadow">(число)</span> - первое значение с плавающей запятой.<br>
&nbsp; 2. &nbsp; <tt>b</tt> - <span class="shadow">(число)</span> - второе значение с плавающей запятой.<br>
&nbsp; 3. &nbsp; <tt>x</tt> - <span class="shadow">(число)</span> - значение, которое линейно интерполируется между параметрами&nbsp;<tt>x</tt> и&nbsp;<tt>y</tt>.<br>

<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(число)</span> - угол в градусах.
<div class=note><b>Примечание:</b> Линейная интерполяция выполняется по формуле <tt>a + x * (b - a)</tt></div></div><br><br>


<h4>Тип: SVG.math.Point</h4>
Точечный объект (point) используется в математической библиотеке для хранения координат&nbsp;<tt>x</tt> и&nbsp;<tt>y</tt>.<br><br>
<code><span class="lnk" onmouseover="show('constructor - конструктор')" onmouseout="hide()">constructor</span>(<span class="lnk" onmouseover="show('координата x')" onmouseout="hide()">x</span>, <span class="lnk" onmouseover="show('координата y')" onmouseout="hide()">y</span>)</code><br>
<div class=list><h5>Синтаксис:</h5>
<pre>var point = new SVG.math.Point(x, y);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>x</tt> - <span class="shadow">(число)</span> - координата точки <tt>Point</tt> по оси&nbsp;<tt>x</tt>.<br>
&nbsp; 2. &nbsp; <tt>y</tt> - <span class="shadow">(число)</span> - координата точки <tt>Point</tt> по оси&nbsp;<tt>y</tt>.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект точка)</span> - новый объект <tt>SVG.math.Point</tt>.

<h5>Примеры:</h5>
<pre>// Creating an new point object (создание нового точечного объекта)
var point = new SVG.math.Point(10, 10);</pre></div><br>

<code><span class="lnk" onmouseover="show('draw - рисовать')" onmouseout="hide()">draw</span>(<span class="lnk" onmouseover="show('svg - сокращ. от англ. слов Scalable Vector Graphics,<br>в данном случае здесь имеется ввиду svg-элемент')" onmouseout="hide()">svg</span>[, <span class="lnk" onmouseover="show('attr - сокращ. англ. слова attributes - атрибуты')" onmouseout="hide()">attr</span>])</code><br>
Функция рисования - это служебная функция, в основном для отладки. Она нарисует круг на SVG в первом аргументе.
The draw function is a utility function mainly for debugging. It will draw a circle on the SVG in the first argument.
<div class=list><h5>Синтаксис:</h5>
<pre>var point = new SVG.math.Point(x, y).draw(svg);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>svg</tt> - <span class="shadow">(объект)</span> The SVG to draw on. Если значением является <tt>null</tt>, точка будет удалена из SVG.<br>
&nbsp; 2. &nbsp; <tt>attr</tt> - <span class="shadow">(объект)</span> - атрибуты (параметры) для круга, который принимает те же атрибуты, что и обычный круг. Дополнительный, необязательный аргумент.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект точка)</span> - It will return itself.</div><br><br>

<h4>Тип: SVG.math.Line</h4>
В математической библиотеке точечный объект используется как для представления линии, так и отрезка линии.<br><br>
<code><span class="lnk" onmouseover="show('constructor - конструктор')" onmouseout="hide()">constructor</span>(<span class="lnk" onmouseover="show('сокращ. англ. слова point - точка')" onmouseout="hide()">p1</span>, <span class="lnk" onmouseover="show('сокращ. англ. слова point - точка')" onmouseout="hide()">p2</span>)</code><br>
Конструктор принимает точечные объекты, которые определяют линию и отрезок линии.
Если функция, например, в виде <tt>y&nbsp;=&nbsp;mx&nbsp;+&nbsp;a</tt>, должна быть смоделирована с этим объектом, нужно просто вычислить две точки из этой функции, смотрите третий пример.
<div class=list><h5>Синтаксис:</h5>
<pre>var line = new SVG.math.Line(p1, p2);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>p1</tt> - <span class="shadow">(объект)</span> - первая точка, определяющая линию.<br>
&nbsp; 2. &nbsp; <tt>p2</tt> - <span class="shadow">(объект)</span> - вторая точка, определяющая линию.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект линия)</span> - новый объект <tt>SVG.math.Line</tt>.
<h5>Примеры:</h5>
<pre>// Creating an new line object (создание нового объекта линия)
var line = new SVG.math.Line(
	new SVG.math.Point(10, 10),
	new SVG.math.Point(20, 20);
);<br>
// Creating an new line by using a custom point object
// Создание новой линии при помощи пользовательского точечного объекта
var line = new SVG.math.Line(
	{x: 10, y:10},
	{x: 20, y:20}
);<br>
// Creating a line object from a *function* on the form `y = mx + a`
// Создание объекта линия из *function* в виде `y = mx + a`
var func = new SVG.math.Line(
	{x: 1, y: m + a},
	{x: 10, y: 10*m + a}
);</pre></div><br>

<code><span class="lnk" onmouseover="show('draw - рисовать')" onmouseout="hide()">draw</span>(<span class="lnk" onmouseover="show('svg - сокращ. от англ. слов Scalable Vector Graphics,<br>в данном случае здесь имеется ввиду svg-элемент')" onmouseout="hide()">svg</span>[, <span class="lnk" onmouseover="show('options - опции, параметры')" onmouseout="hide()">options</span>])</code><br>
Функция рисования - это служебная функция, в основном для отладки. Она нарисует линию на SVG в первом аргументе.
The draw function is a utility function mainly for debugging. It will draw a line on the SVG in the first argument.
<div class=list><h5>Синтаксис:</h5>
<pre>var line = new SVG.math.Line(x, y).draw(svg);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>svg</tt> - <span class="shadow">(объект)</span> - The SVG to draw on. If null it will remove the itself from SVG.<br>
&nbsp; 2. &nbsp; <tt>options</tt> - <span class="shadow">(объект)</span> - параметры (опции) для линии, которая принимает те же параметры, что и обычная линия. Дополнительный, необязательный аргумент.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект линия)</span> It will return itself.</div><br><br>

<code><span class="lnk" onmouseover="show('update - обновление')" onmouseout="hide()">update</span>(<span class="lnk" onmouseover="show('сокращ. англ. слова point - точка')" onmouseout="hide()">p1</span>, <span class="lnk" onmouseover="show('сокращ. англ. слова point - точка')" onmouseout="hide()">p2</span>)</code><br>
Обновляет точки, определяющие данную линию.<br>

TODO:<br>
Если линия была проведена в SVG, она также будет обновлена.
<div class=list><h5>Синтаксис:</h5>
<pre>line.update(x1, x2);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>p1</tt> - <span class="shadow">(объект точка)</span> - первая точка, определяющая линию.<br>
&nbsp; 2. &nbsp; <tt>p2</tt> - <span class="shadow">(объект точка)</span> - вторая точка, определяющая линию.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект линия)</span> It will return itself.</div><br><br>

<code><span onmouseover="show('parallel - параллельно')" onmouseout="hide()">parallel</span>(<span onmouseover="show('line - линия')" onmouseout="hide()">line</span>)</code><br>
Возвращает значение <tt>true</tt>, если данные линии параллельны.
<div class=list><h5>Синтаксис:</h5>
<pre>var isParallel = line.update(line2);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>line</tt> - <span class="shadow">(объект линия)</span> - линия для проверки на параллельность.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; (boolean) - значение <tt>true</tt>, если данные линии параллельны и значение <tt>false</tt> - в противном случае.</div><br><br>

<code><span class="lnk" onmouseover="show('move - перемещать, двигать')" onmouseout="hide()">move</span>(<span class="lnk" onmouseover="show('from - предлог от')" onmouseout="hide()">from</span>, <span class="lnk" onmouseover="show('towards - предлог к, в направлении к')" onmouseout="hide()">towards</span>, <span class="lnk" onmouseover="show('distance - расстояние, дистанция')" onmouseout="hide()">distance</span>)</code><br>
Переход по линии от одной точки (<tt>from</tt>) к другой (<tt>towards</tt>) на расстояние (<tt>distance</tt>). Подробнее смотрите на рисунке ниже.
<div class=list><h5>Синтаксис:</h5>
<pre>line.move(from, towards, distance);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>from</tt> - <span class="shadow">(объект точка)</span> - точка на данной линии, от которой отсчитывается переход <br>
&nbsp; 2. &nbsp; <tt>towards</tt> - <span class="shadow">(объект точка)</span> - точка на данной линии, в направлении которой осуществляется переход<br>
&nbsp; 3. &nbsp; <tt>distance</tt> - <span class="shadow">(число)</span> - расстояние перехода<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект точка)</span> - точка на линии.<br>
<img src="img/svg.math.js2.png" onmouseover="show('SVG.math.move(from, towards, distance)')" onmouseout="hide()"></div><br><br>

<code><span class="lnk" onmouseover="show('intersection - пересечение, точка пересечения')" onmouseout="hide()">intersection</span>(<span class="lnk" onmouseover="show('line - линия')" onmouseout="hide()">line</span>)</code><br>
Возвращает точку пересечения двух линий. У точечного объекта есть дополнительное свойство, которое будет иметь значение <tt>true</tt>, если две линии параллельны, в противном случае - <tt>false</tt>.
<div class=list><h5>Синтаксис:</h5>
<pre>line.intersection(line2);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>line</tt> - <span class="shadow">(объект линия)</span> - линия, с которой нужно найти точку пересечения.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект точка)</span> - специальный точечный объект, представляющий пересечение двух линий.</div><br><br>

<code><span class="lnk" onmouseover="show('mid point (middle point) - средняя точка')" onmouseout="hide()">midPoint</span>()</code><br>
Возвращает среднюю точку отрезка линии.
<div class=list><h5>Синтаксис:</h5>
<pre>line.midPoint();</pre>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект точка)</span> - средняя точка отрезка линии.</div><br><br>

<code><span class="lnk" onmouseover="show('segment length squared - длина отрезка в квадрате')" onmouseout="hide()">segmentLengthSquared</span>()</code><br>
Возвращает длину отрезка линии в квадрате.
<div class=list><h5>Синтаксис:</h5>
<pre>line.segmentLengthSquared();</pre>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(число)</span> длина отрезка линии в квадрате.</div><br><br>

<code><span class="lnk" onmouseover="show('closest linear interpolation - ближайшая линейная интерполяция')" onmouseout="hide()">closestLinearInterpolation</span>(<span class="lnk" onmouseover="show('point - точка')" onmouseout="hide()">point</span>)</code><br>

Calculatates the interpolation (x) value of the closest point on the line to point. This is mainly used internally, it is probably the method closestPoint you want.
<div class=list><h5>Синтаксис:</h5>
<pre>var interpolation = line.closestLinearInterpolation(point);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>point</tt> - <span class="shadow">(объект точка)</span> - The point to find the interpolation value for.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(число)</span> The interpolatioin value.</div><br><br>

<code><span class="lnk" onmouseover="show('interpolated point - ')" onmouseout="hide()">interpolatedPoint</span>(<span class="lnk" onmouseover="show('t')" onmouseout="hide()">t</span>)</code><br>
Вычисляет новую точку с помощью линейной интерполяции. В основном этот метод используется внутренне, при поиске ближайшей точки, средней точки или подобных вычислений.
Calculates, with a linear interpolation, a new point. This is mainly used internally, when finding closest point, midpoint or similar calculations.
<div class=list><h5>Синтаксис:</h5>
<pre>var point = line.interpolatedPoint(t);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>t</tt> - <span class="shadow">(число)</span> - The interpolation value.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект точка)</span> - A point of calculated with a numeric interpolation.</div><br><br>

<code><span class="lnk" onmouseover="show('closest point - ближайшая точка')" onmouseout="hide()">closestPoint</span>(<span class="lnk" onmouseover="show('p - сокращ. англ. слова point - точка')" onmouseout="hide()">p</span>)</code><br>
Вычисляет точку линии, ближайшую к точке, переданной в аргументе <tt>p</tt>.
<div class=list><h5>Синтаксис:</h5>
<pre>var point = line.closestPoint(p);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>p</tt> - <span class="shadow">(объект точка)</span> - точка, для которой нужно найти ближайшую точку на линии.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект точка)</span> - A point of calculated with a numeric interpolation.</div><br><br>

<code><span class="lnk" onmouseover="show('perpendicular line - перпендикулярная линия')" onmouseout="hide()">perpendicularLine</span>(<span class="lnk" onmouseover="show('p - сокращ. англ. слова point - точка')" onmouseout="hide()">p</span>, <span class="lnk" onmouseover="show('distance - расстояние')" onmouseout="hide()">distance</span>)</code><br>
Вычисляет перпендикулярную линию проходящую через точку, указанную в аргументе <tt>p</tt>. Длина линии определяется аргументом <tt>distance</tt>. Средней точкой новой линии будет точка <tt>p</tt>.
<div class=list><h5>Синтаксис:</h5>
<pre>var line2 = line.perpendicularLine(p, distance);</pre>
<h5>Аргументы:</h5>
&nbsp; 1. &nbsp; <tt>p</tt> - <span class="shadow">(объект точка)</span> - средняя точка новой линии.<br>
&nbsp; 2. &nbsp; <tt>distance</tt> - <span class="shadow">(число)</span> - длина новой линии.<br>
<h5>Возврат:</h5>
&nbsp; &#9679; &nbsp; <span class="shadow">(объект линия)</span> - новый объект линия длиной <tt>distance</tt> и средней точкой в точке <tt>p</tt>.</div><br><br>

<h4>Примеры</h4>
<h5>Стрелка</h5>
В этом примере показано, как нарисовать стрелку. Обратите внимание, что это не самый быстрый способ нарисовать данную фигуру, это только пример того, как можно использовать функции из математической библиотеки.<br>

&nbsp; 1. &nbsp; Создадим линейный объект, который определит начало и конец стрелки.
<pre>var shadowPath = new SVG.math.Line(p1, p2);</pre>

&nbsp; 2. &nbsp; Теперь нужно найти the back point of the arrow (точка <tt>p3</tt> на рисунке). Самый простой способ сделать это - использовать функцию перемещения (<tt>move</tt>).
<pre>var p3 = shadowPath.move(shadowPath.p2, shadowPath.p1, distance);</pre>

&nbsp; 3. &nbsp; Теперь рассчитаем тело стрелки. Для этого вычислим перпендикулярные линии через точки <tt>p1</tt> и <tt>p3</tt>. Результат показан на рисунке зелеными точками на черных пунктирных линиях.
<pre>var back = shadowPath.perpendicularLine(shadowPath.p1, arrowThickness);
var front = shadowPath.perpendicularLine(shadowPath.p2, arrowThickness);</pre>

&nbsp; 4. &nbsp; Почти готово, не хватает только последних точек на наконечнике стрелки. На рисунке они показаны зелеными точками на красных пунктирных линиях. Вычислим эти точки тем же способом, что и в предыдущем шаге.
<pre>var arrowhead = shadowPath.perpendicularLine(shadowPath.p2, arrowheadWidth);</pre>

&nbsp; 5. &nbsp; Осталось только нарисовать стрелку.
<pre>var draw = SVG('paper');
draw.polygon(
       [back.p1.x, back.p1.y],
	[front.p1.x, front.p1.y],
	[arrhowhead.p1.x, arrowhead.p1.y],
	[p2.x, p2.y],
	[arrhowhead.p2.x, arrowhead.p2.y],
	[front.p2.x, front.p2.y],
	[back.p2.x, back.p2.y]
);</pre>
<img src="img/svg.math.js3.png" onmouseover="show('пример стрелки')" onmouseout="hide()"></div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-panzoom-js/" target="_blank" id="11">svg.panzoom.js</a></tt>
<div class=indent1><a href="https://github.com/svgdotjs/svg.panzoom.js" target="_blank">svg.panzoom.js</a> a plugin for svg.js which enables panzoom for viewbox elements.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>A plugin for svg.js that enables panzoom for svg elements

<h3>Начало работы</h3>

<pre>npm install @svgdotjs/svg.panzoom.js</pre>

<pre>// enables panZoom
var canvas = SVG().addTo('#id')
  .size(1000,1000).panZoom()

// zoom programatically
canvas.zoom(lvl, point)</pre>

You can configure panZoom by passing options to it.

&nbsp; &#9679; &nbsp; zoomMin: Minimal zoom level<br>
&nbsp; &#9679; &nbsp; zoomMax: Maximal zoom level<br>
&nbsp; &#9679; &nbsp; zoomFactor: How much is zoomed by one mouse wheel step<br>

This could look like this:

<pre>var canvas = SVG().addTo('#id')
  .size(1000,1000)
  .panZoom({zoomMin: 0.5, zoomMax: 20})</pre>

Setting the min and max value will automatically restrict the zoom to the provided level.
However you are still able to change the zoom out of that bonds by calling zoom(lvl) programatically.

On touchable devices a pinchZoom gesture is supported. Min and max values also apply here.

Zooming is animatable, too:

<pre>canvas.zoom(1) // uses center of viewport by default
    .animate()
    .zoom(2, {x:100, y:100}) // zoom into specified point</pre>

To disable panZoom or change its options just call it again with false or the new options.

<h3>API</h3>

svg.panzoom.js adds the .zoom() method to &#60;svg&#62;<br>

&nbsp; &#9679; &nbsp; zoom() - returns current zoom level<br>
&nbsp; &#9679; &nbsp; zoom(Number) - will zoom in or out depending if the Number is greater or less than the current zoom level<br>
&nbsp; &#9679; &nbsp; zoom(Number, {x,y}) - will zoom with the x/y coordinate as center point<br>
&nbsp; &#9679; &nbsp; zoom(Number, new SVG.Point(x,y)) - will zoom with the x/y coordinate as center point<br><br>
<table class="tbl_1" border="1" cellpadding="5">
<tr class="head"><td>Метод</td><td>Возвращаемое значение</td></tr>
<tr valign="top"><td><tt>zoom()</tt></td><td>Number</td></tr>
<tr valign="top"><td><tt>zoom(Number)</tt></td><td>element</td></tr>
<tr valign="top"><td><tt>zoom(Number, {x,y}) </tt></td><td>element</td></tr>
<tr valign="top"><td><tt>zoom(Number, new SVG.Point(x,y))</tt></td><td>element</td></tr></table><br>

<h3>События</h3>

Multiple events are fired doing different actions. This allow you to respond to actions and in some cases stop an action via preventDefault().

zoom is fired when a mouse wheel event or programmable zoom() triggers a zoom. This usually doesn't happen on mobile devices, in which case pinchZoomStart is fired when a zoom happens.

Events fired from SVG.js are CustomEvents, so the arguments passed from svg.panzoom.js are in in the .detail property.<br>
<table class="tbl_1" border="1" cellpadding="5">
<tr class="head"><td>Название события<br>Event Name</td><td>Значение аргумента<br>Argument Value</td><td><br>preventDefault support</td></tr>
<tr valign="top"><td><tt>zoom</tt></td><td><tt>{ lvl, focus }</tt></td><td>YES</td></tr>
<tr valign="top"><td><tt>panStart</tt></td><td><tt>{ event }</tt></td><td>NO</td></tr>
<tr valign="top"><td><tt>panEnd</tt></td><td><tt>{ event }</tt></td><td>NO</td></tr>
<tr valign="top"><td><tt>pinchZoomStart</tt></td><td><tt>{ event }</tt></td><td>YES</td></tr>
<tr valign="top"><td><tt>pinchZoomEnd</tt></td><td><tt>{ event }</tt></td><td>NO</td></tr></table><br>

Where lvl is the new zoom level, focus is point of zoom and event is the event that triggered the action.

An example of stopping a pan-zoom action:

<pre>var canvas = SVG().addTo('#id')
  .size(1000,1000).panZoom()

canvas.on('pinchZoomStart', function(ev) {
    ev.preventDefault()
    // ...
})</pre>
</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-path-js/" target="_blank" id="12">svg.path.js</a></tt>
<div class=indent1><a href="https://github.com/otm/svg.path.js" target="_blank">svg.path.js</a> для прорисовки путей вручную (от Nils Lagerkvist).</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>svg.path.js - это плагин для библиотеки svg.js, предоставляющий вспомогательные функции при прорисовке путей (контуров).<br>
svg.path.js лицензируется в соответствии с условиями лицензии MIT.<br>

<h3>Использование</h3>
Подключите его в своем html-документе, после подключения библиотеки svg.js.
<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.path.js"&#62;&#60;/script&#62;</pre>

<h3>Примеры</h3>
Имеются реальные примеры на <a href="http://otm.github.io/svg.path.js/" target="_blank" onclick='no_js(event)'>http://otm.github.io/svg.path.js/</a>.

<h3>Введение</h3>
Пути состоят из комбинаций следующих элементов:<br>
&nbsp; &#9679; &nbsp; Moveto<br>
&nbsp; &#9679; &nbsp; Lineto<br>
&nbsp; &#9679; &nbsp; Curveto<br>
&nbsp; &#9679; &nbsp; Arcto<br>
&nbsp; &#9679; &nbsp; ClosePath<br>

The different commands are case-sensitive; an upper-case command specifies its arguments as absolute positions, while a lower-case command specified points relative to the current position. It is always possible to specify a negative value as an argument to a command: negative angles will be anti-clockwise, absolute x and y positions will be taken as negative coordinates, negative relative x values will move to the left, and negative relative y values will move upwards.

<h3>Дополнительные сведения</h3>
Для получения дополнительной информации относительно прорисовки путей рекомендуется посмотреть следующие ресурсы:<br>
&nbsp; &#9679; &nbsp; <a href="http://commons.oreilly.com/wiki/index.php/SVG_Essentials/Paths" target="_blank" onclick='no_js(event)'>http://commons.oreilly.com/wiki/index.php/SVG_Essentials/Paths</a><br>
&nbsp; &#9679; &nbsp; <a href="https://developer.mozilla.org/en-US/docs/SVG/Attribute/d" target="_blank" onclick='no_js(event)'>https://developer.mozilla.org/en-US/docs/SVG/Attribute/d</a><br>

<h4>Moveto</h4>

Moveto elements can be thought of as picking up the drawing instrument and setting it down somewhere else. There is no line drawn between the previous point and the specified point. It is good practice to open all paths with a Moveto command, because without an initial Moveto, commands will be executed with the starting point at wherever it happened to be previously, possibly resulting in undefined behaviour.
M({x, y})

Two parameters are required x and y and they are absolute coordinates:

var rect = draw.path().M({x: 100, y: 100})

m({dx, dy})

Two parameters are required dx and dy and they are relative coordinates:

var rect = draw.path().m({x: 100, y: 100})

<h4>Lineto</h4>

Lineto elements will draws a straight line. This line moves from the current position to the specified location.
L({x, y})

Two parameters are required x and y and they are absolute coordinates:

var rect = draw.path().M({x: 100, y: 100}).L({x: 150, y: 150})

l({dx, dy})

Two parameters are required dx and dy and they are relative coordinates:

var rect = draw.path().m({x: 100, y: 100}).l({x: 150, y: 150})

H(x)

This is a special version of the Lineto which specifies a Horizontal movement. One parameter x is required and is absolute.

var rect = draw.path().m({x: 100, y: 100}).H(150)

h(dx)

This is a special version of the Lineto which specifies a Horizontal movement. One parameter dx is required and is relative movement to the right.

var rect = draw.path().m({x: 100, y: 100}).h(150)

V(y)

This is a special version of the Lineto which specifies a Vertival movement. One parameter y is required and is absolute.

var rect = draw.path().m({x: 100, y: 100}).V(150)

v(dy)

This is a special version of the Lineto which specifies a Vertival movement. One parameter dy is required and is the relative movement up.

var rect = draw.path().m({x: 100, y: 100}).v(150)

<h4>Curveto</h4>

Curveto commands specify a Bezier curve. There are two types of Bezier curves: Cubic and Quadratic. Quadratic Bezier curves are a special case of the Cubic bezier curves, in that the control point for each end is the same.
C({c1x, c1y}, {c2x, c2y}, {x, y})

Cubic Bezier curves takes three objects. The two first objects are control points for the initial point and end point respectively in absolute coordinates. The last object is is the end point of the curveto segment.

var rect = draw.path().m({x: 100, y: 100}).C({x: 100, y: 200}, {x: 200, y: 2oo}, {x: 200, y: 100})

c({dc1x, dc1y}, {dc2x, dc2y}, {dx, dy})

Cubic Bezier curves in relative form takes three objects as inputs. The two first objects are control points for the initial point and end point respectively in relative coordinates. The last object is is the end point of the curveto segment. The two control points are both relative to the initial point, not the end point. dx and dy are the distance to the right and down respectively.

var rect = draw.path().M({x: 100, y: 100}).c({x: 0, y: 100}, {x: 100, y: 100}, {x: 100, y: 0})

Q({cx, cy}, {x, y})

Quadratic Bezier curves are a special case of the Cubic bezier curves, in that the control point for each end is the same. cx and cy are the absolute coordinates of the control point, and x and y are absolute coordinates of the end point.

var rect = draw.path().M({x: 100, y: 100}).Q({x: 100, y: 200}, {x: 200, y: 100})

q({dcx, dcy}, {dx, dy})

Quadratic Bezier curve in the relative form. dcx and dcy are the direction in the x and y directions of the control point. dx and dy are the distances in the x and y directions, respectively, of the end point.

var rect = draw.path().M({x: 100, y: 100}).q({x: 50, y: 100}, {x: 100, y: 0})

S({x, y}, {x, y})

For chains of smooth Bezier curves, the T and S commands are available. Their syntax is simpler than the other Curveto commands because it is assumed that the first control point is the reflection about the previous point from the previous control point, or that it actually IS the previous point if there was no previous control point. The S function will draw a Cubic Bezier segment where the two arguments are the second and third parameter in the C function respectively.

var rect = draw.path()
	.M({x: 100, y: 100})
	.C({x: 100, y: 200}, {x: 200, y: 2oo}, {x: 200, y: 100})
	.S({x: 300, y:200}, {x: 300, y: 100}) // The "reflected control point will be `{x:200, y:100}`

T({x, y})

As the S function is a convenience function for drawing Cubic Bezier is the T function a convenience function for drawing Quadratic Bezier curves. The point argument is the endpoint of the curve. The control point will be the reflectins of the previous control point, or the previous point if no control point excists.

<h4>Arcto</h4>

The Arcto will create an elliptical curve rather than a Bezier curve. The center of the arc is calculated from the other variables. The declaration of an arcto is relatively complicated: (rp, xAxisRotate, largeArcFlag, sweepFlag, p). Where rp is the radius in x and y directions respectively; the largeArcFlag has a value of 0 or 1, and determines whether the smallest (0) or largest (1) arc possible is drawn; the sweepFlag is either 0 or 1, and determines if the arc should be swept in a clockwise (1) or anti-clockwise (0) direction. p are the end point of the path. For more informatin see SVG Essentials
A(rx, ry, xAxisRotate, largeArcFlag, sweepFlag, p)

var rect = draw.path()
	.M({x: 125, y: 75})
	.A(100, 50, 0, 0, 0, {x: 225, y: 125})

a(rx, ry, xAxisRotate, largeArcFlag, sweepFlag, p)

Please note that the only relative coordinate is p

var rect = draw.path()
	.M({x: 125, y: 75})
	.a(100, 50, 0, 0, 0, {x: 100, y: 50})

<h4>Closepath</h4>

The ClosePath command will simply draw a straight line from the current position to the first point in the path. It is the simplest command, and takes no parameters. It will take the shortest linear path to the starting point, intersecting other paths if they fall in the way.
Z()

var rect = draw.path()
	.M({x: 100, y: 100})
	.L({x: 150, y: 150})
	.L({x: 100, y: 150})
	.Z()

Utility functions
clear()

Clear the path from all segments.
getSegmentCount()

Get the segment count from the path

var rect = draw.path()
.M(10, 10)
.L(150, 10)
.L({x:150, y:150})
.Z()

console.log('Segment count: ' + rect.getSegmentCount(1))

getSegment(index)

Get the segment with index index from the path

var rect = draw.path()
.M(10, 10)
.L(150, 10)
.L({x:150, y:150})
.Z()

var lineSegment = rect.getSegment(1)

removeSegment(index)

Remove the segement with index index in the path.

var rect = draw.path()
.M(10, 10)
.L(150, 10)
.L({x:150, y:150})
.Z()

rect.removeSegment(3)

replaceSegment(index, segment)

Replace a segment in the path with a new segment.

var rect = draw.path()
.M(10, 10)
.L(150, 10)
.L({x:150, y:150})
.Z()

var lineSegment = rect.getSegment(1)
rect.replaceSegment(1, rect.getSegment(2))
rect.replaceSegment(2, lineSegment)

drawAnimated(options)

Animates the drawing of the path. It takes an optional options object which can have three arguments, duration, delay and easing. duration and delay is in milliseconds, easing can be one of the following:

    &#60;&#62;: ease in and out

        : ease out

    &#60;: ease in
    -: linear
    =: external control
    a function

You can find more documentation regarfing the easing functionality in the main svg.js documentation.

var rect = draw.path()
.M(10, 10)
.L(150, 10)
.L({x:150, y:150})
.Z()
.drawAnimated({
	delay: 3000
})

update(autoredraw)

Get and set if the path should auto redraw when updated.

var rect = draw.path()
	.update(false)
	.M({x: 100, y: 100})
	.L({x: 150, y: 150})
	.L({x: 100, y: 150})
	.Z()

	// nothing happens until we call redraw manually
	rect.redraw()

redraw()

Redraw the path manually

var rect = draw.path()
	.update(false)
	.M({x: 100, y: 100})
	.L({x: 150, y: 150})
	.L({x: 100, y: 150})
	.Z()

	// nothing happens until we call redraw manually
	rect.redraw()

Copyright: Creative Commons: Attribution-Sharealike license Attributions: MDN</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-pathmorphing-js/" target="_blank" id="13">svg.pathmorphing.js</a></tt>
<div class=indent1><a href="https://github.com/svgdotjs/svg.pathmorphing.js" target="_blank">svg.pathmorphing.js</a> to make path animatable</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>A plugin for the svgjs library to enable path morphing / animation

The code of this plugin will move to the core when it's out of experimental status and shortened (to much space for one feature).<br><br>

<h4>Установка</h4>

Установите модуль с помощью npm:

<pre>$ npm install svj.js svg.pathmorphing.js</pre>
Или загрузите плагин из проекта на гитхабе: <a href="https://github.com/svgdotjs/svg.pathmorphing.js.git" target="_blank" onclick='no_js(event)'>https://github.com/svgdotjs/svg.pathmorphing.js.git</a>.<br><br>

<h4>Загрузка</h4>
Для использования плагина непосредственно на веб-странице, подключите его после подключения библиотеки SVG.js:

<pre>&#60;!DOCTYPE HTML&#62;
&#60;html&#62;
&#60;head&#62;
  &#60;script src="scripts/svg.js"&#62;&#60;/script&#62;
  &#60;script src="scripts/svg.pathmorphing.js"&#62;&#60;/script&#62;
&#60;/head&#62;
&#60;body&#62;
  &#60;script type="text/javascript"&#62;
    // ... your SVG script (здесь ваш SVG скрипт)
  &#60;/script&#62;
&#60;/body&#62;
&#60;/html&#62;</pre>
или в качестве модуля:
<pre>const SVG = require('svg.js')
require('svg.pathmorphing.js')

// ... your SVG script (здесь ваш SVG скрипт)</pre><br>

<h4>Использование</h4>
Использование аналогично любой другой анимации, описанной в документации svg.js:
<pre>var draw = SVG('drawing').viewbox(0, 0, 300, 300)<br>
// create path (создание пути)
var path = draw.path('M150 0 L75 200 L225 200 Z')<br>
// animate path (анимация пути)
path.animate().plot('M100 0 H190 V90 H100 Z')</pre>
Довольно прямолинейно, не так ли?<br><br>

<h4>Зависимости</h4>
Для работы данного модуля требуется svg.js, версии большей или равной 2.1.1</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-resize-js/" target="_blank" id="14">svg.resize.js</a></tt>
<div class=indent1><a href="https://github.com/fuzzyma/svg.resize.js" target="_blank">svg.resize.js</a> to resize elements with your mouse.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>An extension of svg.js which allows to resize elements which are selected with svg.select.js<br>

For a demo see http://svgdotjs.github.io/svg.resize.js/<br><br>

<h4>Начало работы</h4>

    Install svg.resize.js using bower:
<pre>bower install svg.resize.js</pre>

    Include the script after svg.js and svg.select.js into your page

<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.select.js"&#62;&#60;/script&#62;
&#60;script src="svg.resize.js"&#62;&#60;/script&#62;</pre>

    Select a rectangle and make it resizeable:
<pre>&#60;div id="myDrawing"&#62;&#60;/div&#62;<br>
var drawing = new SVG('myDrawing').size(500, 500);
drawing.rect(50,50).selectize().resize()</pre>

<h4>Использование</h4>

Activate resizing

<pre>var draw = SVG('drawing');
var rect = draw.rect(100,100);
rect.selectize().resize();</pre>

Deactivate resizing

<pre>rect.resize('stop');</pre>

Keep element within constrained box

<pre>var draw = SVG('drawing');
var rect = draw.rect(100, 100);
var opt = {
	constraint: {
		minX: 0,
		minY: 0,
		maxX: 200,
		maxY: 300
	}
};
rect.selectize().resize(opt)</pre><br>

<h4>Опции</h4>

    snapToGrid: Snaps the shape to a virtual grid while resizing (default 1)
    snapToAngle: Snaps to an angle when rotating (default 0.1)
    constraint: Keep element within constrained box (see usage above); The box snaps to the grid defined by snapToGrid.
    saveAspectRatio: Save aspect ratio of the element while resizing with left-top, left-bottom, right-top, right-bottom points.<br><br>

<h4>События</h4>

    resizing: Fired when changes occur
    resizedone: Fired when resizing is done<br><br>

<h4>Известные проблемы</h4>

    resize nested svgs does not work</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-screenbbox-js/" target="_blank" id="15">svg.screenbbox.js</a></tt>
<div class=indent1><a href="https://github.com/fuzzyma/svg.screenbbox.js" target="_blank">svg.screenbbox.js</a> to get the bbox in screen coordinates from transformed path/polygon/polyline</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>A plugin for the svgjs library which gets the bbox of a path/polygon/polyline after all transformations applied.<br>

The returned bounding box is in the screens coordinate space which means that the scroll offset is not applied (same as with screenCTM)<br><br>

<h4>Начало работы</h4>

<pre>bower install svg.screenbbox.js</pre>

<pre>// add some viewbox madness to make this more interesting
var nested = draw.viewbox(0, 0, 300, 200).nested().viewbox(-50, 20, 200, 300)

// create path with transformation
var path = draw.path('M150 0 L75 200 L225 200 Z').rotate(25).scale(0.5)

// get bounding box in screen coordinates
var bbox = path.screenBBox()

// do something with it, e.g. draw a reactangle around (with jQuery here)
$('&#60;div&#62;').css({
  position:'absolute',
  width:bbox.width,
  height:bbox.height,
  left:bbox.x+window.pageXOffset, // dont forget to add the scroll offset
  top:bbox.y+window.pageYOffset,  // dito
  outline:'3px solid black'
}).appendTo('body')</pre><br>

<h4>Зависимости</h4>

This module requires svg.js >= v2.2.0
</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-select-js/" target="_blank" id="16">svg.select.js</a></tt>
<div class=indent1><a href="https://github.com/fuzzyma/svg.select.js" target="_blank">svg.select.js</a> to select elements.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>An extension of svg.js which allows to select elements with mouse

<div class=note><b>Примечание:</b> Duo to naming conflicts the exported method was renamed from select() to selectize().</div>

For a demo see http://svgdotjs.github.io/svg.select.js/<br><br>

<h4>Начало работы</h4>

    Install svg.select.js using bower:
<pre>bower install svg.select.js</pre>

    Include the script after svg.js into your page
<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.select.js"&#62;&#60;/script&#62;</pre>

    Select a rectangle using this simple piece of code:
<pre>&#60;div id="myDrawing"&#62;&#60;/div&#62;<br>
var drawing = new SVG('myDrawing').size(500, 500);
drawing.rect(50,50).selectize()</pre>

<h4>Использование</h4>

Select

<pre>var draw = SVG('drawing');
var rect = draw.rect(100,100);
rect.selectize();<br>
// or deepSelect
rect.selectize({deepSelect:true});</pre>

Unselect

<pre>rect.selectize(false);<br>
// or deepSelect
rect.selectize(false, {deepSelect:true});</pre>

You can specify which points to be drawn (default all will be drawn)<br>

The list can be an array of strings or a comma separated list / string, representing each position, in correspondence with the classes:<br>
&nbsp; &#9679; &nbsp; lt - left top<br>
&nbsp; &#9679; &nbsp; rt - right top<br>
&nbsp; &#9679; &nbsp; rb - right bottom<br>
&nbsp; &#9679; &nbsp; lb - left bottom<br>
&nbsp; &#9679; &nbsp; t - top<br>
&nbsp; &#9679; &nbsp; r - right<br>
&nbsp; &#9679; &nbsp; b - bottom<br>
&nbsp; &#9679; &nbsp; l - left<br>

Example of drawing only top and right points:

<pre>rect.selectize({
  points: ['t', 'r'] // or 't, r'
})</pre>

There is also an extra option called pointsExclude which can be a list of points to be excluded from the points list.<br>

So let's say that you need all the points except top and right:

<pre>rect.selectize({
  pointsExclude: ['t', 'r'] // or 't, r'
})</pre>

You can style the selection with the classes<br>
&nbsp; &#9679; &nbsp; svg_select_boundingRect<br>
&nbsp; &#9679; &nbsp; svg_select_points<br>
&nbsp; &#9679; &nbsp; svg_select_points_lt - left top<br>
&nbsp; &#9679; &nbsp; svg_select_points_rt - right top<br>
&nbsp; &#9679; &nbsp; svg_select_points_rb - right bottom<br>
&nbsp; &#9679; &nbsp; svg_select_points_lb - left bottom<br>
&nbsp; &#9679; &nbsp; svg_select_points_t - top<br>
&nbsp; &#9679; &nbsp; svg_select_points_r - right<br>
&nbsp; &#9679; &nbsp; svg_select_points_b - bottom<br>
&nbsp; &#9679; &nbsp; svg_select_points_l - left<br>
&nbsp; &#9679; &nbsp; svg_select_points_rot - rotation point<br>
&nbsp; &#9679; &nbsp; svg_select_points_point - deepSelect points<br>

<h4>Опции</h4>
&nbsp; &#9679; &nbsp; points: Points should be drawn (default ['lt', 'rt', 'rb', 'lb', 't', 'r', 'b', 'l'])<br>
&nbsp; &#9679; &nbsp; pointsExclude: Same as points option, only thing that this excludes listed points, you can use (default [])<br>
&nbsp; &#9679; &nbsp; classRect: Classname of the rect from the bounding Box (default svg_select_boundingRect)<br>
&nbsp; &#9679; &nbsp; classPoints: Classname/Prefix of the Points (default svg_select_points)<br>
&nbsp; &#9679; &nbsp; pointSize: Size of the point. Radius for the pointType: 'circle' or size of a rect for pointType: 'rect' (default 7)<br>
&nbsp; &#9679; &nbsp; rotationPoint: Draws the point for doing rotation (default true)<br>
&nbsp; &#9679; &nbsp; deepSelect: Only for polygon/polyline/line. Selects the points itself (default false)<br>
&nbsp; &#9679; &nbsp; pointType: Type of a point, circle or rect or function (see functions for drawing circle or rect points) (default circle)</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-shapes-js/" target="_blank" id="17">svg.shapes.js</a></tt>
<div class=indent1>Плагин <a href="https://github.com/svgdotjs/svg.shapes.js" target="_blank">svg.shapes.js</a> увеличивает число фигур на основе многоугольников.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Это плагин библиотеки SVG.js для рисования различных типов фигур на основе встроенного метода многоугольников (полигонов).<br>
svg.path.js лицензируется в соответствии с условиями лицензии MIT.<br>

<h3>Использование</h3>
Подключите его в своем html-документе, после подключения библиотеки svg.js.
<pre>&#60;script src="svg.js"&#62;&#60;/script&#62;
&#60;script src="svg.shapes.js"&#62;&#60;/script&#62;</pre><br>

<h4>Star (звезда)</h4>
Чтобы нарисовать звезду требуется три параметра, внутренний радиус (inner), внешний радиус (outer) и количество лучей (spikes):
<pre>var star = draw.polygon().star({
  inner:  50
, outer:  100
, spikes: 7
})</pre>
Данный метод можно анимировать:
<pre>star.animate().star({ spikes: 10 })</pre>
Наконец, если нужно получить только данные точек, построитель звезды доступен напрямую, вот так:
<pre>SVG.shapes.star({ spikes: 10 })</pre>
Обратите внимание, что этот метод вернет экземпляр SVG.PointArray.<br>

<h5>Ngon (многоугольник)</h5>
Для метода ngon() требуется только два параметра, радиус (radius) и количество сторон (edges):

<pre>var ngon = draw.polygon().ngon({
  radius: 150
, edges: 	5
})</pre>
Данный метод также можно анимировать:
<pre>star.animate().ngon({ edges: 7, radius: 200 })</pre>
И, если нужно получить только данные точек, построитель многоугольника доступен напрямую, вот так:
<pre>SVG.shapes.ngon({ edges: 10 })</pre>
Обратите внимание, что этот метод вернет экземпляр SVG.PointArray.<br>

<h4>To-do</h4>
Cog wheel (зубчатое колесо)<br>
Wedge (клин)<br>
Arc (дуга)<br>
Cross (крест)</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-textmorph-js/" target="_blank" id="18">svg.textmorphing.js</a></tt>
<div class=indent1>Плагин <a href="https://github.com/svgdotjs/svg.textmorph.js" target="_blank">svg.textmorph.js</a> предназначен для анимации текста.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>Плагин библиотеки SVG.js to enable text morphing / animation. Этот плагин зависим от плагина svg.pathmorphing.js.<br>

In order to morph text, we have to convert the text to paths.<br>

So at first we need to load an svg-font which holds the path definition for every glyph:

<pre>new SVG.SVGFont(font, callback, lazyloading)</pre>
&nbsp; &#9679; &nbsp; font can be an xml string containing a font element, an id pointing to an element containing a font element or can be a path to a file.<br>

&nbsp; &#9679; &nbsp; The callback is called when the font is loaded (which is neccessary when the file asynchronously loaded).<br>

&nbsp; &#9679; &nbsp; lazyloading specifies if the glyphs should only be pulled from the font if needed or cached all together when loading the font. This parameter is true per default which means lazyloading is active.<br>

Пример:
<pre>new SVG.SVGFont('myFont.svg', function(){
  // callback is called in context of the font

  // lets use the font
  var text = draw.morphText('ABCDEFG').font({
    family:this, // or this.family or just the font-family which is specified in the font
    size:50
  })

  // animate the text
  text.animate().text('GFEDCBA')

})</pre>

<h4>Зависимости</h4>
Этот модуль требует для работы версию SVG.js большую или равную 2.1.1 и версию плагина svg.pathmorphing.js большую или равную 0.1.0.</div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-topath-js/" target="_blank" id="19">svg.topath.js</a></tt>
<div class=indent1>Плагин <a href="https://github.com/svgdotjs/svg.topath.js" target="_blank">svg.topath.js</a> для конвертирования любой другой фигуры в путь.</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>svg.topath.js - плагин библиотеки SVG.js, который преобразует любую другую фигуру в путь.<br>
svg.topath.js лицензируется в соответствии с условиями лицензии MIT.<br><br>
<h4>Установка</h4>
<pre>npm install @svgdotjs/svg.topath.js</pre><br>
<h4>Использование</h4>
Подключите данный плагин в своем html-документе, после подключения библиотеки SVG.js или затребуйте / импортируйте его.<br>
Для конвертирования любой другой фигуры в путь:
<pre>var canvas = SVG().addTo('body')<br>
var rect = canvas.rect(100, 200).attr({ rx: 10, ry: 5 })<br>
var rectPath = rect.toPath()</pre>
По умолчанию, вновь созданный путь <b>заменит</b> исходную фигуру. Если замена фигура не нужна, используйте <tt>toPath(false)</tt>.<br>
В дальнейшем, новый путь возвращается и может быть добавлен в документ:
<pre>rect = rect.toPath(false).insertAfter(rect)</pre></div></div><br>

&nbsp; &#9679; &nbsp; <tt><a href="https://svgjs.com/docs/3.0/plugins/svg-topoly-js/" target="_blank" id="20">svg.topoly.js</a></tt>
<div class=indent1>Плагин <a href="https://github.com/svgdotjs/svg.topoly.js" target="_blank">svg.topoly.js</a> для конвертирования пути (path) в многоугольник (polygon) или ломаную линию (polyline).</div>
<div class=indent1><a class='link' onclick='javascript:show_txt(this)'> &nbsp; &nbsp; &nbsp; Справка по плагину</a>
<div style='display:none;' onclick='javascript:show_txt(this)'>svg.topoly.js - это плагин библиотеки SVG.js для конвертирования путей в многоугольники или ломаные линии.<br>
svg.topoly.js лицензируется в соответствии с условиями лицензии MIT.<br>

<h4>Установка</h4>
<pre>npm install @svgdotjs/svg.topoly.js</pre>

<h3>Использование</h3>
Подключите данный плагин в своем html-документе, после подключения библиотеки SVG.js или затребуйте / импортируйте его.<br>
Для конвертирования пути в многоугольник:
<pre>const data = 'M82.3,160.4c6.5,5.2,13.6,9.5,21.2,12.8c7.6,3.3,14.7,4.9,21.5,4.9c7.3,0,12.6-1.1,15.9-3.4c3.3-2.2,4.9-5.4,4.9-9.5 c0-2.2-0.6-4.1-1.7-5.6c-1.1-1.5-2.8-2.9-4.9-4.2c-2.2-1.3-4.7-2.6-7.7-3.8c-3-1.2-6.5-2.6-10.4-4.1l-22.7-9.5 c-4.9-1.9-9.5-4.3-14-7.4c-4.5-3.1-8.4-6.7-11.8-10.9c-3.4-4.2-6-9-8-14.5c-2-5.4-2.9-11.4-2.9-18c0-7.9,1.7-15.2,5.1-22 c3.4-6.8,8-12.8,14-18c6-5.1,13.1-9.2,21.5-12.2c8.3-3,17.4-4.5,27.4-4.5c10.5,0,21.1,2,31.9,5.9c10.8,3.9,20.3,10.1,28.8,18.5 L166,85.1c-6.2-4.3-12.1-7.6-17.8-9.8c-5.7-2.2-11.9-3.4-18.7-3.4c-6,0-10.7,1-14,3.1c-3.4,2.1-5.1,5.1-5.1,9.3 c0,4.3,2.4,7.6,7.2,10c4.8,2.3,11.4,5.1,19.8,8.3l22.2,8.7c11.4,4.5,20.2,10.8,26.4,18.8c6.2,8,9.3,18.4,9.3,31.2 c0,7.7-1.6,15.1-4.8,22.2c-3.2,7.1-7.8,13.3-13.9,18.7c-6.1,5.3-13.5,9.6-22.3,12.8c-8.8,3.2-18.9,4.8-30.3,4.8 c-11.6,0-23.5-2.1-35.8-6.3c-12.3-4.2-23.3-10.8-33.3-19.8L82.3,160.4z'

const canvas = SVG().addTo('body')

var path = canvas.path(data)

var polygon = path.toPoly()</pre>
По умолчанию, вновь созданный путь <b>заменит</b> исходную фигуру. Если замена фигура не нужна, используйте <tt>toPoly(false)</tt>.<br>
The newly created path will replace the original shape by default. If you don't want your shape to be replaced, use toPath(false).<br>

The new path is given back and can be added to the document later:

<pre>rect = rect.toPath(false).insertAfter(rect)</pre>

<h4>Samples</h4>

The default sample value is '1%'. This means that every 1% of the total length of the path, a point will be registered. Please note, that the fixpoints of the path commands are always added as extra points. This means, that '1%' will not always result in 100 points. Instead it will be more like 100 + number of path commands.<br>

There are three ways to approach the sample value.<br>

<code>% value</code><br>

This will insert a point every x% of the total length.

<h5>Пример:</h5>
<pre>path.toPoly('0.5%')</pre><br>

<code>px value</code><br>

This will add points on a fixed distance until the total length is reached.
<h5>Пример:</h5>
<pre>path.toPoly('3px')</pre>

<code>number value</code><br>

This will equally spread a given amount of samples over the total length.

<h5>Пример:</h5>
<pre>path.toPoly(400)</pre>

<h4>Типы</h4>

If a path is closed (ending with a z) a SVG.Polygon will be generated, otherwise a SVG.Polyline.

<h4>SVG.PathArray</h4>
Метод <tt>toPoly()</tt> на SVG.Path является посредником того же самого метода на SVG.PathArray. Это делает возможным конвертирование данных пути в данные точки, даже без прорисовки фигуры:
The toPoly() method on a SVG.Path is a proxy to the same method on SVG.PathArray. This makes it possible to convert path data to point data, even without ever drawing a shape:

<pre>var pathArray = new SVG.PathArray(data)<br>
var pointArray = path.toPoly('1%')
// -> returns an instance of SVG.PointArray
// -> возвращает экземпляр SVG.PointArray</pre></div></div><br>

</div>

<br><br>
</body></html>
